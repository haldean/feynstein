\subsection*{feynstein/Built.java}
\begin{lstlisting}
package feynstein;

public abstract class Built<E extends Built> {
    /**
     *  Built classes should override this method, which is guaranteed
     *  to be called after all parameters are set using builder
     *  syntax.
     */
    protected String objectType;

    @SuppressWarnings("unchecked")
    public E compile() {
	return (E) this;
    }

    public String toString() {
	return objectType;
    }
}\end{lstlisting}

\subsection*{feynstein/ClassGetter.java}
\begin{lstlisting}
package feynstein;

class ClassGetter extends SecurityManager {
    public Class getCurrentClass() {
	Class[] classes = getClassContext();
	Class c =  classes[3];
	return c;
    }
}\end{lstlisting}

\subsection*{feynstein/Scene.java}
\begin{lstlisting}
package feynstein;


import feynstein.forces.*;
import feynstein.geometry.*;
import feynstein.properties.*;
import feynstein.properties.collision.*;
import feynstein.properties.integrators.*;
import feynstein.shapes.*;
import feynstein.utilities.*;

import java.awt.Frame;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.media.opengl.awt.*;
import com.jogamp.opengl.util.*;

public abstract class Scene {
    public static GLCanvas canvas = new GLCanvas();
    public static Frame frame = new Frame("Feynstein");
    public static Animator animator = new Animator(canvas);

    protected Map<String, Shape> shapes;
    protected List<Force> forces;
    protected Map<Class, Property> propertyMap;
    protected ArrayList<NarrowPhaseDetector> detectorList;
    protected List<Property> properties; //without collision responders, integrators
    protected List<Property> responders;
    protected Mesh mesh;
    protected Integrator integrator;
    private boolean hasInteg; //whether user's defined default already
    private boolean steppedInResponse;
	
    double[] globalForces;
    double[] globalPositions;
    double[] globalVelocities;
    double[] globalMasses;

    public Scene() {
	mesh = new Mesh();

	shapes = new HashMap<String, Shape>();
	forces = new ArrayList<Force>();
	properties = new ArrayList<Property>();
	responders = new ArrayList<Property>();
	propertyMap = new HashMap<Class, Property>();
	detectorList = new ArrayList<NarrowPhaseDetector>();

	//integrator = new SemiImplicitEuler(this);
	//hasInteg = false;

	createShapes();
	setProperties();
	createForces();
		
	globalForces = new double[3*mesh.size()];
	globalPositions = new double[3*mesh.size()];
	globalVelocities = new double[3*mesh.size()];
	globalMasses = new double[3*mesh.size()];
    }

    protected static void print(String str) {
	System.out.println(str);
    }

    public void addShape(Shape s) {
	print("Adding " + s.toString());
	shapes.put(s.getName(), s);
	mesh.append(s.getLocalMesh());
    }

    public Shape getShape(String name) {
	return shapes.get(name);
    }

    public void addForce(Force f) {
	print("Adding " + f.toString());
	forces.add(f);
    }
	
    public void addProperty(Property p) {
	print("Adding " + p.toString());

	if (p instanceof CollisionResponder) {
	    responders.add(p);
	} else if (p instanceof Integrator) {
	    // if (hasInteg)
	    integrator = (Integrator) p;
	} else {
	    properties.add(p);
	}

	propertyMap.put(p.getClass(), p);

	if (p instanceof NarrowPhaseDetector)
	    detectorList.add((NarrowPhaseDetector) p);
    }

    @SuppressWarnings("unchecked")
    public <E extends Property> E getProperty(Class c) {
	return (E) propertyMap.get(c);
    }

    public NarrowPhaseDetector getDetectorByIndex(int index) {
	return detectorList.get(index);
    }

    public Integrator getIntegrator() {
	return integrator;
    }
	
    public Mesh getMesh() {
	return mesh;
    }

	/**
     * This method steps through the list of local force 
     * potentials, evaluates each force potential, and then 
     * update a global force magnitude list 
     */	
	public void updateGlobalForce() {
		for(int i = 0; i < mesh.size(); i++) {
			// get global positions
			globalPositions[3*i] = mesh.getParticles().get(i).getPos().x();
			globalPositions[3*i+1] = mesh.getParticles().get(i).getPos().y();
			globalPositions[3*i+2] = mesh.getParticles().get(i).getPos().z();
			// get global velocitiyes
			globalVelocities[3*i] = mesh.getParticles().get(i).getVel().x();
			globalVelocities[3*i+1] = mesh.getParticles().get(i).getVel().y();
			globalVelocities[3*i+2] = mesh.getParticles().get(i).getVel().z();
			// get global masses
			globalMasses[3*i] = mesh.getParticles().get(i).getMass();
			globalMasses[3*i+1] = mesh.getParticles().get(i).getMass();
			globalMasses[3*i+2] = mesh.getParticles().get(i).getMass();
		}		
		globalForces = getForcePotential(globalPositions, globalVelocities, globalMasses);
	}
	
	/*
	 * Gets the force potential given a new set of positions
	 */
	public double[] getForcePotential(double [] positions, double [] velocities, double [] masses) {
		double [] forcePotential = new double[positions.length];
		
		//for each force potential
		for(Force force : forces){
			//get the local force vector
			double [] localForce = force.getLocalForce(positions, velocities, masses);
			//add to the global force vector at cooresponding particle
			//indicies
			if(force.isGlobal()) {
				for(int i = 0; i < localForce.length; i++){
					forcePotential[i] += localForce[i];
				}
			} else {
				for(int i = 0; i < localForce.length/3; i++){
					forcePotential[3*force.getStencilIdx(i)] += localForce[3*i];
					forcePotential[3*force.getStencilIdx(i)+1] += localForce[3*i+1];
					forcePotential[3*force.getStencilIdx(i)+2] += localForce[3*i+2];
				}
			}
		}
		return forcePotential;
	}
	
    public double[] globalForceMagnitude() {
	return globalForces;
    }
    
    public void setGlobalForces(double[] newGlobalForces) {
	globalForces = newGlobalForces;
    }

    public double[] getGlobalPositions() {
	return globalPositions;
    }

    public double[] getGlobalVelocities() {
	return globalVelocities;
    }

    public void setGlobalVelocities(double[] newVels) {
	globalVelocities = newVels;
    }
	
	public double[] getGlobalMasses() {
		return globalMasses;
    }

    public void update() {
	updateGlobalForce();

	for (Property property : properties) 
	    property.update();
	for (Property property : responders) {
	    property.update();
	    if (!steppedInResponse)
		integrator.update();
	}
	onFrame();
	steppedInResponse = false;
    }

    public void hasStepped(boolean b) {
	steppedInResponse = b;
    }

    public abstract void setProperties();
    public abstract void createShapes();
    public abstract void createForces();
    public abstract void onFrame();
}\end{lstlisting}

\subsection*{feynstein/geometry/Edge.java}
\begin{lstlisting}
package feynstein.geometry;

public class Edge {
	private int [] idx;
	
	public Edge (int idx1, int idx2) {
		idx = new int[2];
		idx[0] = idx1;
		idx[1] = idx2;
	}
	
	public int getIdx(int index) {
		if(index < 2)
			return idx[index];
		return -1;
	}
}\end{lstlisting}

\subsection*{feynstein/geometry/Mesh.java}
\begin{lstlisting}
package feynstein.geometry;
import feynstein.utilities.Vector3d;

import java.util.ArrayList;

public class Mesh {
    private ArrayList<Particle> particles;
    private ArrayList<Edge> edges;
    private ArrayList<Triangle> triangles;
	
    public Mesh() {
	this.particles = new ArrayList<Particle>();
	this.edges = new ArrayList<Edge>();
	this.triangles = new ArrayList<Triangle>();
    }
	
    public Mesh(ArrayList<Particle> particles, ArrayList<Edge> edges, 
		ArrayList<Triangle> triangles) {
	this.particles = particles;
	this.edges = edges;
	this.triangles = triangles;
    }
	
    public ArrayList<Particle> getParticles() {
	return particles;
    }
	
    public ArrayList<Edge> getEdges() {
	return edges;
    }
	
    public ArrayList<Triangle> getTriangles() {
	return triangles;
    }
	
    public Vector3d getVert(int index) {
	return particles.get(index).getPos();
    }
    
    public int size() {
	return particles.size();
    }
	
    public void append(Mesh localMesh) {
		int shift = particles.size();
		for (Particle p : localMesh.getParticles()) {
			particles.add(p);
		}
		for (int i = 0; i < localMesh.getEdges().size(); i++) {
			Edge e = localMesh.getEdges().get(i);
			e = new Edge(e.getIdx(0)+shift, e.getIdx(1)+shift);
			localMesh.getEdges().set(i, e);
			edges.add(e);
		}
		for (int i = 0; i < localMesh.getTriangles().size(); i++) {
			Triangle t = localMesh.getTriangles().get(i);
			t = new Triangle(t.getIdx(0)+shift, t.getIdx(1)+shift, t.getIdx(2)+shift);
			localMesh.getTriangles().set(i, t);
			triangles.add(t);
		}
	}
	
}\end{lstlisting}

\subsection*{feynstein/geometry/Triangle.java}
\begin{lstlisting}
package feynstein.geometry;
import feynstein.utilities.Vector3d;

public class Triangle {
    private int [] idx;
    private Vector3d [] normals;
	
    public Triangle(int idx0, int idx1, int idx2) {
	idx = new int [3];
	idx[0] = idx0;
	idx[1] = idx1;
	idx[2] = idx2;
    }
	
    public Triangle(int [] idx) {
	this.idx = idx;
    }
	
    public void setNormals(Vector3d n1, Vector3d n2, Vector3d n3) {
	normals = new Vector3d [3];
	normals[0] = n1;
	normals[1] = n2;
	normals[2] = n3;
    }
	
    public int getIdx(int index) {
	if(index < 3)
	    return idx[index];
	return -1;
    }

    public boolean contains(int index) {
	for (int i = 0; i < 3; i++)
	    if(idx[i]==index)
		return true;
	return false;
    }

    /**
     * Returns true if the two triangles share at least one vertex.
     */
    public boolean overlaps(Triangle t) {
	for (int i=0; i<3; i++) {
	    for (int j=0; j<3; j++) {
		if (idx[i] == t.idx[j]) return true;
	    }
	}
	return false;
    }

    public String toString() {
	return "Triangle (" + idx[0] + ", " + idx[1] + ", " + idx[2] + ")";
    }
}\end{lstlisting}

\subsection*{feynstein/geometry/Transform.java}
\begin{lstlisting}
package feynstein.geometry;

import feynstein.geometry.Particle;
import feynstein.utilities.Vector3d;

public class Transform {
    private double[] A;

    public Transform() {
	A = new double[9];
    }

    public Transform(double[] mat) {
	if (mat.length != 9) {
	    throw new RuntimeException("Transformation matrices must be of length 9.");
	}

	A = mat;
    }

    public void apply(Particle particle) {
	apply(particle.getPos());
    }

    public void apply(Vector3d vector) {
	double[] result = new double[3];
	for (int i=0; i<3; i++) {
	    for (int j=0; j<3; j++) {
		result[i] += A[3*i + j] * vector.get(j);
	    }
	}
	
	vector.set(result[0], result[1], result[2]);
    }

    public static Transform scale(double sx, double sy, double sz) {
	return new Transform(new double[] {sx, 0, 0, 
					   0, sy, 0, 
					   0, 0, sz});
    }

    public static Transform rotateX(double rx) {
	return new Transform(new double[] {1, 0, 0,
					   0, Math.cos(rx), -Math.sin(rx),
					   0, Math.sin(rx), Math.cos(rx)});
    }

    public static Transform rotateY(double ry) {
	return new Transform(new double[] {Math.cos(ry), 0, Math.sin(ry),
					   0, 1, 0,
					   -Math.sin(ry), 0, Math.cos(ry)});
    }

    public static Transform rotateZ(double rz) {
	return new Transform(new double[] {Math.cos(rz), -Math.sin(rz), 0,
					   Math.sin(rz), Math.cos(rz), 0,
					   0, 0, 1});
    }

}\end{lstlisting}

\subsection*{feynstein/geometry/Particle.java}
\begin{lstlisting}
package feynstein.geometry;
import feynstein.utilities.Vector3d;

public class Particle {
	private int obj_index;
	private int part_index;
	//position
	private Vector3d pos;
	//velocity
	private Vector3d vel;
	private boolean fixed;
	//mass
	private double mass;
	//render size
	private float size;
	
	public Particle(Vector3d initialPos) {
		pos = initialPos;
		vel = new Vector3d(0,0,0);
		fixed = false;
		size = 0;
		mass = 1;
	}
	
	public void setMass(double mass) {
		this.mass = mass;
	}
	
	public void setSize(float size) {
		this.size = size;
	}
	
	public boolean isFixed() {
		return fixed;
	}
	
	public void setFixed(boolean fixed) {
		this.fixed = fixed;
	}
	
	public Vector3d getPos() {
		return pos;
	}
	
	public Vector3d getVel() {
		return vel;
	}
	
	public double getMass() {
		return mass;
	}
	
	public float getSize() {
		return size;
	}

	public void setVel(Vector3d vel) {
	    this.vel = vel;
	}
	
	public void update(Vector3d pos, Vector3d vel) {
		this.pos = pos;
		this.vel = vel;
	}
}\end{lstlisting}

\subsection*{feynstein/utilities/Vector3d.java}
\begin{lstlisting}
package feynstein.utilities;

public class Vector3d {
	
    private double x, y, z;
	
    public Vector3d() {
	set(0,0,0);
    }
	
    public Vector3d(double vx, double vy, double vz) {
	set(vx, vy, vz);
    }
	
    public void set(double vx, double vy, double vz) {
	x = vx;
	y = vy;
	z = vz;
    }
	
    public double get(int i) {
	switch(i){
	case 0:
	    return x;
	case 1:
	    return y;
	default:
	    return z;
	}
    }
	
    public double x() {
	return x;
    }
	
    public double y() {
	return y;
    }
	
    public double z() {
	return z;
    }

    public Vector3d normalize() {
	double magnitude = norm();
	if(magnitude != 0) {
	    return new Vector3d(x/magnitude, y/magnitude, z/magnitude);
	}

	return new Vector3d(0,0,0);
    }
	
    public double norm() {
	return Math.sqrt(dot(this));
    }

    public boolean zero() {
	return x == 0 && y == 0 && z == 0;
    }
	
    public Vector3d plus(Vector3d other) {
	return new Vector3d(x+other.x, y+other.y, z+other.z);
    }

    public void add(Vector3d other) {
	x += other.x;
	y += other.y;
	z += other.z;
    }
	
	public Vector3d add(double s) {
		return new Vector3d(x+s, y+s, z+s);
    }

    public Vector3d minus(Vector3d other) {
	return new Vector3d(x-other.x, y-other.y, z-other.z);
    }
	
	public Vector3d minus(double s) {
		return new Vector3d(x-s, y-s, z-s);
    }

    public void subtract(Vector3d other) {
	x -= other.x;
	y -= other.y;
	z -= other.y;
    }
	
    public double dot(Vector3d other) {
	return x*other.x + y*other.y + z*other.z;
    }
	
    public Vector3d dot(double s) {
	return new Vector3d(s*x, s*y, s*z);
    }
	
    public Vector3d cross(Vector3d other) {
	return new Vector3d(y * other.z - z * other.y, z * other.x - x * other.z, 
			    x * other.y - y * other.x);
    }
	
    public boolean equals(Vector3d other) {
	return x==other.x && y==other.y && z==other.z;
    }
	
    public String toString() {
	return "[" + x + " " + y + " " + z + "]";
    }
	
    public Vector3d copy() {
	return new Vector3d(x, y, z);
    }
}\end{lstlisting}

\subsection*{feynstein/utilities/ObjParser.java}
\begin{lstlisting}
package feynstein.utilities;
import feynstein.geometry.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class ObjParser {
	private final String VERTEX = "v";
	private final String FACE = "f";
	private final String TEXCOORD = "vt";
	private final String NORMAL = "vn";
	// Shit we may need later for materials
	/*
	 private final String OBJECT = "o";
	private final String MATERIAL_LIB = "mtllib";
	private final String USE_MATERIAL = "usemtl";
	private final String NEW_MATERIAL = "newmtl";
	private final String DIFFUSE_TEX_MAP = "map_Kd";
	//private HashMap<String, ObjMaterial> materialMap;
	 */
	
	private String fileName;

	private ArrayList<Particle> verts;
	private ArrayList<Edge> edges;
	private ArrayList<Triangle> tris;
	private ArrayList<Vector3d> normals;
	
	private Mesh mesh;
	
	/**
	 * Creates a new OBJ parser instance
	 * 
	 */
	public ObjParser(String fileName) throws FileNotFoundException {
		this.fileName = fileName;
		mesh = parse();
		//materialMap = new HashMap<String, ObjMaterial>();
	}

	public Mesh getMesh() {
		return mesh;
	}
	
	private Mesh parse() throws FileNotFoundException {
		verts = new ArrayList<Particle>();
		edges = new ArrayList<Edge>();
		tris = new ArrayList<Triangle>();
		normals = new ArrayList<Vector3d>();
		
		BufferedReader buffer = new BufferedReader(
				new FileReader(fileName));
		String line;
		try {
			while ((line = buffer.readLine()) != null) {
				// remove duplicate whitespace
				StringTokenizer parts = new StringTokenizer(line, " ");
				int numTokens = parts.countTokens();
				if (numTokens == 0)
					continue;
				String type = parts.nextToken();

				// add vertex to particles list
				if (type.equals(VERTEX)) {
					double x = Float.parseFloat(parts.nextToken());
					double y = Float.parseFloat(parts.nextToken());
					double z = Float.parseFloat(parts.nextToken());
					
					Vector3d vertex = new Vector3d(x,y,z);
					verts.add(new Particle(vertex));
					
				} else if (type.equals(FACE)) {
					
					Triangle newTri = parseTriangleFace(line, numTokens-1);
					tris.add(newTri);
					
				} else if (type.equals(NORMAL)) {
					double x = Float.parseFloat(parts.nextToken());
					double y = Float.parseFloat(parts.nextToken());
					double z = Float.parseFloat(parts.nextToken());
					Vector3d normal = new Vector3d(x,y,z);
					normals.add(normal);
				}  
				// MATERIALS SHIT WE WILL NEED LATER
				/*else if (type.equals(TEXCOORD)) {
					Uv texCoord = new Uv();
					texCoord.u = Float.parseFloat(parts.nextToken());
					texCoord.v = Float.parseFloat(parts.nextToken()) * -1f;
					texCoords.add(texCoord);
				}
				else if (type.equals(MATERIAL_LIB)) {
					readMaterialLib(parts.nextToken());
				} else if (type.equals(USE_MATERIAL)) {
					currentMaterialKey = parts.nextToken();
				}
				}*/
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		return new Mesh(verts, edges, tris);
	}

	private Triangle parseTriangleFace(String line, int faceLength) {
		boolean emptyVt = line.indexOf("//") > -1;
		if(emptyVt) {
			line = line.replace("//", "/");
		}
		StringTokenizer parts = new StringTokenizer(line);
		parts.nextToken();
		StringTokenizer subParts = new StringTokenizer(parts.nextToken(), "/");
		int partLength = subParts.countTokens();
		boolean hasuv = partLength >= 2 && !emptyVt;
		boolean hasn = partLength == 3 || (partLength == 2 && emptyVt);
		
		int [] v = new int[faceLength];
		int [] uv = new int[faceLength];
		int [] n = new int[faceLength];
		
		for (int i = 0; i < faceLength; i++) {
			if (i > 0)
				subParts = new StringTokenizer(parts.nextToken(), "/");
			
			int index = i;
			v[index] = (short) (Short.parseShort(subParts.nextToken()) - 1);
			if (hasuv) {
				uv[index] = (short) (Short.parseShort(subParts.nextToken()) - 1);
			}
			if (hasn) {
				n[index] = (short) (Short.parseShort(subParts.nextToken()) - 1);
			}
		}
		// TODO(sam): this method assumes that face length is 3. If there are more, we 
		// should handle them accordingly
		Triangle t = new Triangle(v);
		if(hasn)
			t.setNormals(normals.get(n[0]), normals.get(n[1]), normals.get(n[2]));
		return t;
	}
	
	// Materials shit we may need later
	/*private void readMaterialLib(String libID) {
		StringBuffer resourceID = new StringBuffer(packageID);
		StringBuffer libIDSbuf = new StringBuffer(libID);
		int dotIndex = libIDSbuf.lastIndexOf(".");
		if (dotIndex > -1)
			libIDSbuf = libIDSbuf.replace(dotIndex, dotIndex + 1, "_");

		resourceID.append(":raw/");
		resourceID.append(libIDSbuf.toString());

		InputStream fileIn = resources.openRawResource(resources.getIdentifier(
				resourceID.toString(), null, null));
		BufferedReader buffer = new BufferedReader(
				new InputStreamReader(fileIn));
		String line;
		String currentMaterial = "";

		try {
			while ((line = buffer.readLine()) != null) {
				String[] parts = line.split(" ");
				if (parts.length == 0)
					continue;
				String type = parts[0];

				if (type.equals(NEW_MATERIAL)) {
					if (parts.length > 1) {
						currentMaterial = parts[1];
						materialMap.put(currentMaterial, new ObjMaterial(
								currentMaterial));
					}
				} else if (type.equals(DIFFUSE_TEX_MAP)) {
					if (parts.length > 1) {
						materialMap.get(currentMaterial).diffuseTextureMap = parts[1];
						StringBuffer texture = new StringBuffer(packageID);
						texture.append(":drawable/");

						StringBuffer textureName = new StringBuffer(parts[1]);
						dotIndex = textureName.lastIndexOf(".");
						if (dotIndex > -1)
							texture.append(textureName.substring(0, dotIndex));
						else
							texture.append(textureName);

						int bmResourceID = resources.getIdentifier(texture
								.toString(), null, null);
						Bitmap b = Utils.makeBitmapFromResourceId(bmResourceID);
						textureAtlas.addBitmapAsset(new BitmapAsset(currentMaterial, texture.toString()));
					}
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	
	private class ObjMaterial {
		public String name;
		public String diffuseTextureMap;
		public float offsetU;
		public float offsetV;

		public ObjMaterial(String name) {
			this.name = name;
		}
	}*/
}
\end{lstlisting}

\subsection*{feynstein/properties/Property.java}
\begin{lstlisting}
package feynstein.properties;

import feynstein.*;

public abstract class Property<E extends Property> extends Built<E> {
    final Scene scene;
	
    public Property(Scene scene) {
	this.scene = scene;
	objectType = "Property";
    }
	
    public Scene getScene() {
	return scene;
    }
	
    public abstract void update();
	
    @SuppressWarnings("unchecked") public E compile() {
	return (E) this;
    }
}\end{lstlisting}

\subsection*{feynstein/properties/collision/NarrowPhaseDetector.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.*;
import feynstein.geometry.*;
import feynstein.utilities.Vector3d;
import feynstein.properties.*;

import java.util.*;

public abstract class NarrowPhaseDetector<E extends NarrowPhaseDetector> extends Property<E> {
    
    protected Mesh mesh;
    protected Scene scene;
    protected String name;

    protected final BoundingVolumeHierarchy bvh;
    protected final boolean enableBvh;

    protected HashSet<Collision> actualCollisions;

    public NarrowPhaseDetector(Scene aScene) {
	super(aScene);
	actualCollisions = new HashSet<Collision>();

	scene = aScene;
	mesh = scene.getMesh();

	bvh = scene.getProperty(BoundingVolumeHierarchy.class);
	enableBvh = bvh != null;
    }

    public abstract HashSet<Collision> checkCollision(TrianglePair p, HashSet<Collision> cSet);

    public HashSet<Collision> getCollisions() {
	return actualCollisions;
    }

    /*@SuppressWarnings("unchecked")
    public E set_name(String aName) {
	name = aName;
	return (E) this;
	}*/

    public String getName() {
	return name;
    }

    protected double getVertex(Triangle t, int vertex, int axis) {
	return mesh.getVert(t.getIdx(vertex)).get(axis);
    }

    public void update() {
	actualCollisions.clear();

	if (enableBvh) {
	    List<TrianglePair> collisions = bvh.getCollisions();
	    for (TrianglePair pair : collisions)
		checkCollision(pair, actualCollisions);
		//(checkCollision adds the collision to the given set as a side effect
	} else {
	    Triangle t1, t2;
	    for (int i = 0; i < mesh.getTriangles().size(); i++) {
		for (int j = i+1; j < mesh.getTriangles().size(); j++) {
		    t1 = mesh.getTriangles().get(i);
		    t2 = mesh.getTriangles().get(j);
		    checkCollision(new TrianglePair(t1, t2), actualCollisions);
		}
	    }
	}
	
	//TESTING PURPOSES ONLY:
	for (Collision c : actualCollisions)
	    System.out.println(c.toString());
    }

}\end{lstlisting}

\subsection*{feynstein/properties/collision/SpringPenaltyResponder.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.*;
import feynstein.properties.*;
import feynstein.utilities.*;
import java.util.*;

public class SpringPenaltyResponder extends CollisionResponder<SpringPenaltyResponder> {
    
    double k; //stiffness
    double proximity;

    public SpringPenaltyResponder(Scene aScene) {
	super(aScene);
	k = 500;
    }

    public SpringPenaltyResponder set_stiffness(double stiffness) {
	k = stiffness;
	return this;
    }

    public SpringPenaltyResponder set_proximity(double p) {
	proximity = p;
	return this;
    }

    @SuppressWarnings("unchecked")
    public void update() {
	// (responders always updated after detectors--see Scene.java)
	HashSet<Collision> cSet = detector.getCollisions();
	if (cSet.size() > 0) {
	    double[] penalties = calculatePenaltyForces(scene.getGlobalPositions(), 
							scene.getGlobalVelocities(), cSet);
	    double[] globalForces = scene.globalForceMagnitude();

	    for (int i = 0; i < globalForces.length; i++) {
		globalForces[i] += penalties[i];
	    }
	    scene.setGlobalForces(globalForces);
	}
    }

    private double[] calculatePenaltyForces(double[] X, double[] V, HashSet<Collision> cSet) {
	double[] penalty = new double[X.length];

	//for each collision, apply the penalties
	for (Collision col : cSet) {
	    //Collision col = col_rec[i];
	    //vertex-face collision
	    if(col.getType() == Collision.VERTEX_FACE){
			System.out.println("VERTEX-FACE");
		//get indicies
		int[] parts = col.getParticles();
		int p = parts[0];
		int a = parts[1]; 
		int b = parts[2]; 
		int c = parts[3];

		//get barycentric coords
		double[] bc = col.getBaryCoords();
		double u = bc[0];
		double v = bc[1];
		double w = bc[2];

		//get collision point and collision velocities
		Vector3d xa = new Vector3d(); //was Vector3d xa, xb, va, vb;
		Vector3d xb = new Vector3d();
		Vector3d va = new Vector3d();
		Vector3d vb = new Vector3d();

		xa.set(X[3*p], X[3*p + 1], X[3*p + 2]);
		xb.set(u*X[3*a] + v*X[3*b] + w*X[3*c],
		       u*X[3*a + 1] + v*X[3*b + 1] + w*X[3*c + 1],
		       u*X[3*a + 2] + v*X[3*b + 2] + w*X[3*c + 2]);
		va.set(V[3*p], V[3*p + 1], V[3*p + 2]);
		vb.set(u*V[3*a] + v*V[3*b] + w*V[3*c],
		       u*V[3*a + 1] + v*V[3*b + 1] + w*V[3*c + 1],
		       u*V[3*a + 2] + v*V[3*b + 2] + w*V[3*c + 2]);

			System.out.println("REL VEL "+xa.minus(xb).dot(va.minus(vb))+" "+va+" "+vb+" "+xa+" "+xb);
			System.out.println("REL VEL2 "+xb.minus(xa).dot(vb.minus(va)));
		/*if the objects have do not have
		  a seperating velocity, apply the 
		  local spring penalty */
		if(xa.minus(xb).dot(va.minus(vb)) < 0) {
		    double[] local_penalty = springPenalty(xa, xb, col.getDistance());
		    //apply to vertex
		    penalty[3*p] += local_penalty[0];
		    penalty[3*p + 1] += local_penalty[1];
		    penalty[3*p + 2] += local_penalty[2];

		    //apply to triangle coordinates
		    penalty[3*a] += bc[0] * local_penalty[3];
		    penalty[3*a + 1] +=  bc[0] * local_penalty[4];
		    penalty[3*a + 2] +=  bc[0] * local_penalty[5];
		    penalty[3*b] +=  bc[1] * local_penalty[3];
		    penalty[3*b + 1] +=  bc[1] * local_penalty[4];
		    penalty[3*b + 2] +=  bc[1] * local_penalty[5];
		    penalty[3*c] +=  bc[2] * local_penalty[3];
		    penalty[3*c + 1] +=  bc[2] * local_penalty[4];
		    penalty[3*c + 2] +=  bc[2] * local_penalty[5];
		}
	    }
		
	    //edge-edge collision
	    if(col.getType() == Collision.EDGE_EDGE){
		//get indicies
		int[] parts = col.getParticles();
		int p1 = parts[0];
		int q1 = parts[1];
		int p2 = parts[2];
		int q2 = parts[3];

		//get barycentric coords
		double[] coords = col.getBaryCoords();
		double s = coords[0];
		double t = coords[1];

		Vector3d xa = new Vector3d(); //was Vector3d xa, xb, va, vb;
		Vector3d xb = new Vector3d();
		Vector3d va = new Vector3d();
		Vector3d vb = new Vector3d();

		//edge points
		xa.set(s*X[3*p1] + (1-s)*X[3*q1],
		       s*X[3*p1 + 1] + (1-s)*X[3*q1+1],
		       s*X[3*p1 + 2] + (1-s)*X[3*q1+2]);
		xb.set(t*X[3*p2]+(1-t)*X[3*q2],
		       t*X[3*p2+1]+(1-t)*X[3*q2+1],
		       t*X[3*p2+2]+(1-t)*X[3*q2+2]);

		//velocities
		va.set(	s*V[3*p1]+(1-s)*V[3*q1],
			s*V[3*p1+1]+(1-s)*V[3*q1+1],
			s*V[3*p1+2]+(1-s)*V[3*q1+2]);
		vb.set(	t*V[3*p2]+(1-t)*V[3*q2],
			t*V[3*p2+1]+(1-t)*V[3*q2+1],
			t*V[3*p2+2]+(1-t)*V[3*q2+2]);

		/*if the objects have do not have
		  a seperating velocity, apply the 
		  local spring penalty */
		if(xa.minus(xb).dot(va.minus(vb)) < 0) {
		    double[] local_penalty = springPenalty(xa, xb, col.getDistance());
		    //apply penalty to first edge
		    penalty[3*p1] += s*local_penalty[0];
		    penalty[3*p1+1] += s*local_penalty[1];
		    penalty[3*p1+2] += s*local_penalty[2];
		    penalty[3*q1] += (1-s)*local_penalty[0];
		    penalty[3*q1+1] += (1-s)*local_penalty[1];
		    penalty[3*q1+2] += (1-s)*local_penalty[2];
		    //apply penalty to second edge
		    penalty[3*p2] += t*local_penalty[3];
		    penalty[3*p2+1] += t*local_penalty[4];
		    penalty[3*p2+2] += t*local_penalty[5];
		    penalty[3*q2] += (1-t)*local_penalty[3];
		    penalty[3*q2+1] += (1-t)*local_penalty[4];
		    penalty[3*q2+2] += (1-t)*local_penalty[5];
		}
	    }
		
	}

	return penalty;
    }

    private double[] springPenalty(Vector3d xi, Vector3d xj, double dist) {
	double[] F = new double[6];
	//collision normal
	Vector3d n = xi.minus(xj);
	n = n.dot(1 / n.norm());
	
	F[0] = -(k * (n.x()) * (-2 * proximity + dist));
	F[1] = -(k * (n.y()) * (-2 * proximity + dist));
	F[2] = -(k * (n.z()) * (-2 * proximity + dist));
	F[3] = -F[0];
	F[4] = -F[1];
	F[5] = -F[2];

	return F;
    }
}\end{lstlisting}

\subsection*{feynstein/properties/collision/BoundingVolume.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.geometry.*;

public abstract class BoundingVolume {
    public double x_lower;
    public double x_upper;
    public double y_lower;
    public double y_upper;
    public double z_lower;
    public double z_upper;

    public abstract boolean overlaps(BoundingVolume v);
    public abstract void fitTriangle(Triangle t, Mesh mesh);
    public abstract void fitTriangles(Triangle[] ts, Mesh mesh);
    public abstract void addMargin(double margin);
    public abstract void merge(BoundingVolume v1, BoundingVolume v2);

    public String toString() {
	return "X: (" + x_lower + ", " + x_upper + "), Y: (" + y_lower + 
	    ", " + y_upper + "), Z: (" + z_lower + ", " + z_upper + ")";
    }
}\end{lstlisting}

\subsection*{feynstein/properties/collision/ContinuousTimeDetector.java}
\begin{lstlisting}
 package feynstein.properties.collision;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;
import feynstein.*;
import feynstein.properties.*;
import java.util.*;

import com.numericalmethod.suanshu.analysis.function.polynomial.root.jenkinstraub.*;
import com.numericalmethod.suanshu.analysis.function.polynomial.*;
import com.numericalmethod.suanshu.datastructure.list.*;
import com.numericalmethod.suanshu.license.*;
import org.joda.time.*;
import java.lang.Number;

public class ContinuousTimeDetector extends NarrowPhaseDetector<ContinuousTimeDetector> {

    JenkinsTraubReal cubic;
    double[] op;
    double[] time;
    double[] zeroi;
    double[] a;
    double[] b;
    double[] c;
    double[] p;
    double[] p1;
    double[] q1;
    double[] p2;
    double[] q2;

    private double h = 0;      

    public ContinuousTimeDetector(Scene aScene) {
	super(aScene);
	cubic = new JenkinsTraubReal();
	op = new double[4];
	time = new double[3];
	zeroi = new double[3];
	a = new double[3];
	b = new double[3];
	c = new double[3];
	p = new double[3];
	p1 = new double[3];
	q1 = new double[3];
	p2 = new double[3];
	q2 = new double[3];
    }

    public ContinuousTimeDetector set_stepSize(double step) {
	h = step;
	return this;
    }
    
    public HashSet<Collision> checkCollision(TrianglePair p, HashSet<Collision> cSet) {
	return checkCollision(p.t1, p.t2, cSet);
    }

    public HashSet<Collision> checkCollision(Triangle t1, Triangle t2, HashSet<Collision> cSet) {
	double[] X = scene.getGlobalPositions();
	double[] V = scene.getGlobalVelocities();

	if (t1.getIdx(0) == t2.getIdx(0) || t1.getIdx(0) == t2.getIdx(1) 
	    || t1.getIdx(0) == t2.getIdx(2) || t1.getIdx(1) == t2.getIdx(0) 
	    || t1.getIdx(1) == t2.getIdx(1) || t1.getIdx(1) == t2.getIdx(2) 
	    || t1.getIdx(2) == t2.getIdx(1) || t1.getIdx(2) == t2.getIdx(1) 
	    || t1.getIdx(2) == t2.getIdx(2)) {
	    return cSet; // because you can't hit yourself
	}
	boolean collision = false;
	double hit_t = -1;
	double u = -1, v = -1, w = -1, s = -1, t = -1;
	double vx0, vy0, vz0, vx1, vy1, vz1, vx2, vy2, vz2, vx3, vy3, vz3;
	//degrees of freedom
	int n = X.length/3;
	//check all 15 possible collisions
	for (int i = 0; i < 15; i++) {
	    boolean confirmed = false;
	    //the triangle with which the vertex is colliding
	    Triangle tri = null;
	    //the colliding vertex index
	    int vertex = -1;
	    //collding edge indicies
	    int p_1 = -1, q_1 = -1, p_2 = -1, q_2 = -1;
	    double x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3;
	    //vertex face
	    if (i < 6) {
		if (i < 3) {
		    tri = t1;
		    if(i == 0) vertex = t2.getIdx(0);
		    if(i == 1) vertex = t2.getIdx(1);
		    if(i == 2) vertex = t2.getIdx(2);
		}
		else {
		    tri = t2;
		    if(i == 3) vertex = t1.getIdx(0);
		    if(i == 4) vertex = t1.getIdx(1);
		    if(i == 5) vertex = t1.getIdx(2);
		}
			
				
		//vertex position and velocity
		x3  = X[3*vertex];
		y3 = X[3*vertex+1];
		z3 = X[3*vertex+2];
		vx3 = V[3*vertex];
		vy3 = V[3*vertex+1];
		vz3 = V[3*vertex+2];
		//triangle vertex positions and velocities
		x0 = X[3*tri.getIdx(0)];
		y0 = X[3*tri.getIdx(0)+1];
		z0 = X[3*tri.getIdx(0)+2];
		x1 = X[3*tri.getIdx(1)];
		y1 = X[3*tri.getIdx(1)+1];
		z1 = X[3*tri.getIdx(1)+2];
		x2 = X[3*tri.getIdx(2)];
		y2 = X[3*tri.getIdx(2)+1];
		z2 = X[3*tri.getIdx(2)+2];
		//velocities
		vx0 = V[3*tri.getIdx(0)];
		vy0 = V[3*tri.getIdx(0)+1];
		vz0 = V[3*tri.getIdx(0)+2];
		vx1 = V[3*tri.getIdx(1)];
		vy1 = V[3*tri.getIdx(1)+1];
		vz1 = V[3*tri.getIdx(1)+2];
		vx2 = V[3*tri.getIdx(2)];
		vy2 = V[3*tri.getIdx(2)+1];
		vz2 = V[3*tri.getIdx(2)+2];
				
		Vector3d v10 = new Vector3d();
		Vector3d v20 = new Vector3d();
		Vector3d v30 = new Vector3d();
		Vector3d x10 = new Vector3d();
		Vector3d x20 = new Vector3d();
		Vector3d x30 = new Vector3d();

		//relaitve positions and velocities
		x10.set(X[3*tri.getIdx(1)]-X[3*tri.getIdx(0)],
			X[3*tri.getIdx(1)+1]-X[3*tri.getIdx(0)+1],
			X[3*tri.getIdx(1)+2]-X[3*tri.getIdx(0)+2]);
		x20.set(X[3*tri.getIdx(2)]-X[3*tri.getIdx(0)],
		        X[3*tri.getIdx(2)+1]-X[3*tri.getIdx(0)+1],
		        X[3*tri.getIdx(2)+2]-X[3*tri.getIdx(0)+2]);
		x30.set(X[3*vertex]-X[3*tri.getIdx(0)],
			X[3*vertex+1]-X[3*tri.getIdx(0)+1],
			X[3*vertex+2]-X[3*tri.getIdx(0)+2]);
		v10.set(V[3*tri.getIdx(1)]-V[3*tri.getIdx(0)],
			V[3*tri.getIdx(1)+1]-V[3*tri.getIdx(0)+1],
			V[3*tri.getIdx(1)+2]-V[3*tri.getIdx(0)+2]);
		v20.set(V[3*tri.getIdx(2)]-V[3*tri.getIdx(0)],
			V[3*tri.getIdx(2)+1]-V[3*tri.getIdx(0)+1],
			V[3*tri.getIdx(2)+2]-V[3*tri.getIdx(0)+2]);
		v30.set(V[3*vertex]-V[3*tri.getIdx(0)],
			V[3*vertex+1]-V[3*tri.getIdx(0)+1],
			V[3*vertex+2]-V[3*tri.getIdx(0)+2]);
				
		/*[v10, v20, v30]t^3 + ([x10, v20, v30]+[v10, x20, v30]+[v10, v20, x30])t^2
		  +([x10, x20, v30]+[x10,v20,x30]+[v10, x20, x30])t+[x10,x20, x30]
		*/
		op[0] = v10.dot(v20.cross(v30));
		op[1] = x10.dot(v20.cross(v30)) + v10.dot(x20.cross(v30)) + v10.dot(v20.cross(x30));
		op[2] = x10.dot(x20.cross(v30)) + x10.dot(v20.cross(x30)) + v10.dot(x20.cross(x30));
		op[3] = x10.dot(x20.cross(x30));
			
	    }
		
	    //edge-edge
	    else {
		if (i < 9) {
		    p_1 = t1.getIdx(0); 
		    q_1 = t1.getIdx(1); 
		    if (i == 6) { p_2 = t2.getIdx(0); q_2 = t2.getIdx(1); }
		    if (i == 7) { p_2 = t2.getIdx(0); q_2 = t2.getIdx(2); }
		    if (i == 8) { p_2 = t2.getIdx(1); q_2 = t2.getIdx(2); }
		}
		else if(i < 12){
		    p_1 = t1.getIdx(0); 
		    q_1 = t1.getIdx(2);
		    if(i==9){ p_2 = t2.getIdx(0); q_2 = t2.getIdx(1); }
		    if(i==10){ p_2 = t2.getIdx(0); q_2 = t2.getIdx(2); }
		    if(i==11){ p_2 = t2.getIdx(1); q_2 = t2.getIdx(2); }
		}
		else if (i < 15){
		    p_1 = t1.getIdx(1); 
		    q_1 = t1.getIdx(2);
		    if(i==12){ p_2 = t2.getIdx(0); q_2 = t2.getIdx(1); }
		    if(i==13){ p_2 = t2.getIdx(0); q_2 = t2.getIdx(2); }
		    if(i==14){ p_2 = t2.getIdx(1); q_2 = t2.getIdx(2); }
		}
		
		//edge vertex points
		x0 = X[3*p_1];
		y0 = X[3*p_1+1];
		z0 = X[3*p_1+2];
		x1 = X[3*q_1];
		y1 = X[3*q_1+1];
		z1 = X[3*q_1+2];
		x2 = X[3*p_2];
		y2 = X[3*p_2+1];
		z2 = X[3*p_2+2];
		x3 = X[3*q_2];
		y3 = X[3*q_2+1];
		z3 = X[3*q_2+2];
		//edge vertex velocities
		vx0 = V[3*p_1];
		vy0 = V[3*p_1+1];
		vz0 = V[3*p_1+2];
		vx1 = V[3*q_1];
		vy1 = V[3*q_1+1];
		vz1 = V[3*q_1+2];
		vx2 = V[3*p_2];
		vy2 = V[3*p_2+1];
		vz2 = V[3*p_2+2];
		vx3 = V[3*q_2];
		vy3 = V[3*q_2+1];
		vz3 = V[3*q_2+2];

		//edges and radius between first two edge points
		Vector3d v10 = new Vector3d();
		Vector3d v20 = new Vector3d();
		Vector3d v30 = new Vector3d();
		Vector3d x10 = new Vector3d();
		Vector3d x20 = new Vector3d();
		Vector3d x30 = new Vector3d();


		x10.set(X[3*q_1]-X[3*p_1],
			X[3*q_1+1]-X[3*p_1+1],
			X[3*q_1+2]-X[3*p_1+2]);
		x30.set(X[3*p_2]-X[3*p_1],
			X[3*q_2+1]-X[3*p_2+1],
			X[3*p_2+2]-X[3*p_1+2]);
		x20.set(X[3*q_2]-X[3*p_2],
			X[3*q_2+1]-X[3*p_2+1],
			X[3*q_2+2]-X[3*p_2+2]);
		v10.set(V[3*q_1]-V[3*p_1],
			V[3*q_1+1]-V[3*p_1+1],
			V[3*q_1+2]-V[3*p_1+2]);
		v30.set(V[3*p_2+1]-V[3*p_1+1],
			V[3*p_2+1]-V[3*p_1+1],
			V[3*p_2+2]-V[3*p_1+2]);
		v20.set(V[3*q_2]-V[3*p_2],
			V[3*q_2+1]-V[3*p_2+1],
			V[3*q_2+2]-V[3*p_2+2]);
				
		/*[v10, v20, v30]t^3 + ([x10, v20, v30]+[v10, x20, v30]+[v10, v20, x30])t^2
		  +([x10, x20, v30]+[x10,v20,x30]+[v10, x20, x30])t+[x10,x20, x30]
		*/

		op[0] = v10.dot(v20.cross(v30));
		op[1] = x10.dot(v20.cross(v30)) + v10.dot(x20.cross(v30)) + v10.dot(v20.cross(x30));
		op[2] = x10.dot(x20.cross(v30)) + x10.dot(v20.cross(x30)) + v10.dot(x20.cross(x30));
		op[3] = x10.dot(x20.cross(x30));
				
	    }
		
	    //get roots of cubic time function
	    time[0] = -1.0;
	    time[1] = -1.0;
	    time[2] = -1.0;
		
		boolean print = (vertex==4&&tri.getIdx(0)==0&&tri.getIdx(1)==1&&tri.getIdx(2)==2);
		if(print) {
			System.out.println("COEFF "+op[0]+" "+op[1]+" "+op[2]+" "+op[3]+" "
							   +vertex+" "+tri.getIdx(0)+" "+tri.getIdx(1)+" "+tri.getIdx(2));
		}//else {
			//System.out.println("COEFF "+op[0]+" "+op[1]+" "+op[2]+" "+op[3]+" "
			//				   +p_1+" "+q_1+" "+p_2+" "+q_2);
		//}
	    // Creates a Polynomial from a list of coefficients and solves
	    // for its roots.
	    // root-finder fails if op[0]==0, and polynomial is not cubic
	    if (Math.abs(op[0]) > 1E-10) {
			try{
				NumberList list = cubic.solve(new Polynomial(op));
				Object[] roots = list.toArray();
				int timeIndex = 0;
				// Looks through the root list for real-number roots and,
				// if there are any, stores them in the time array.
				for (int j = 0; j < roots.length; j++) {
					try {
						time[timeIndex] = ((Number) roots[j]).doubleValue();
						timeIndex++;
					} catch (IllegalArgumentException iae) {
					}
				}
			} catch (Exception e) {
				
			}
			//if(print)
			//	System.out.println("Root "+list.toString())
				
		
	    }
	    //quadratic roots: (if (b != 0)) 
	    else if(Math.abs(op[1]) > 1E-10){
		time[0] = (-1*op[2]+Math.sqrt(op[2]*op[2]-4*op[1]*op[3]))/(2*op[1]);
		time[1] = (-1*op[2]-Math.sqrt(op[2]*op[2]-4*op[1]*op[3]))/(2*op[1]);
	    }
	    //linear root
	    else{
		time[0] = (-1*op[3])/op[2];
	    }
			
	    //if any roots are between 0 and time h
	    //collision = true;
	    if(time[0] >= 0 && time[0] <= h+1e-3){
		collision = true;
		hit_t = time[0];
	    }
	    if(time[1] >= 0 && time[1] <= h+1e-3){
		collision = true;
		hit_t = time[1];
	    }
	    if(time[2] >= 0 && time[2] <= h+1e-3){
		collision = true;
		hit_t = time[2];
	    }
		
		if(print)
			System.out.println("TIMES "+time[0]+" "+time[1]+" "+time[2]+" "+collision);
				
	    //store collision
	    if (collision) {
			

		//vertex-face collision point
		if(i < 6) {
		    p[0] = x3+hit_t*vx3;
		    p[1] = y3+hit_t*vy3;
		    p[2] = z3+hit_t*vz3;
		    a[0] = x0+hit_t*vx0;
		    a[1] = y0+hit_t*vy0;
		    a[2] = z0+hit_t*vz0;
		    b[0] = x1+hit_t*vx1;
		    b[1] = y1+hit_t*vy1;
		    b[2] = z1+hit_t*vz1;
		    c[0] = x2+hit_t*vx2;
		    c[1] = y2+hit_t*vy2;
		    c[2] = z2+hit_t*vz2;
		    //check for false-positive
		    double[] distAndCoords = DistanceFinder.vertexFaceDistance(p, a, b, c, u, v, w);
		    if(distAndCoords[0] < .000001){
			u = distAndCoords[1];
			v = distAndCoords[2];
			w = distAndCoords[3];
				//if(print) {
					System.out.println(distAndCoords[0]);
					System.out.println(p[0]+" "+p[1]+" "+p[2]+", "+a[0]+" "+a[1]+" "+a[2]+", "
									   +b[0]+" "+b[1]+" "+b[2]+", "+c[0]+" "+c[1]+" "+c[2]+", ");
					System.out.println(vx3+" "+vy3+" "+vz3+", "+vx0+" "+vy0+" "+vz0+", "
									   +vx1+" "+vy1+" "+vz1+", "+vx2+" "+vy2+" "+vz2+", ");
					
				//}
			cSet.add(new Collision(Collision.VERTEX_FACE, u, v, w, vertex, tri.getIdx(0), tri.getIdx(1), tri.getIdx(2), 0.0));
				 }
					
		    }
				
		    //edge-edge
		    else {
			//edge-edge collision points
			p1[0] = x0+hit_t*vx0;
			p1[1] = y0+hit_t*vy0;
			p1[2] = z0+hit_t*vz0;
			q1[0] = x1+hit_t*vx1;	
			q1[1] = y1+hit_t*vy1;
			q1[2] = z1+hit_t*vz1;
			p2[0] = x2+hit_t*vx2;
			p2[1] = y2+hit_t*vy2;
			p2[2] = z2+hit_t*vz2;
			q2[0] = x3+hit_t*vx3;
			q2[1] = y3+hit_t*vy3;
			q2[2] = z3+hit_t*vz3;

			//check for false-positive
			double[] distAndCoords = DistanceFinder.edgeEdgeDistance(p1, q1, p2, q2, s, t);
			if (distAndCoords[0] < .000001) {
			    s = distAndCoords[0];
			    t = distAndCoords[1];
			    cSet.add(new Collision(Collision.EDGE_EDGE, 1.0 - s, 1.0 - t, 0.0, p_1, q_1, p_2, q_2, 0.0));
			}
		    }
	    }
	    collision = false;
	}
	return cSet;
    }
}\end{lstlisting}

\subsection*{feynstein/properties/collision/ImpulseResponder.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.*;
import feynstein.geometry.*;
import feynstein.properties.*;
import feynstein.properties.integrators.*;
import feynstein.utilities.*;
import java.util.*;

public class ImpulseResponder extends CollisionResponder<ImpulseResponder> {

    Integrator integrator;
    int iter;

    double X[];
    double M[];	
    double[] newPos; //q
    double[] newVels; //q_dot
    double[] midStepPos; //Q
    double[] midStepVel; //Q_dot

    public ImpulseResponder(Scene aScene) {
	super(aScene);
	integrator = scene.getIntegrator();
	iter = 100;
	midStepPos = new double[scene.getMesh().size() * 3];
	midStepVel = new double[midStepPos.length];
    }

    public ImpulseResponder set_iterations(int iterations) {
	iter = iterations;
	return this;
    }
    
    @SuppressWarnings("unchecked")
    public void update() {
	X = scene.getGlobalPositions();
	M = scene.getGlobalMasses();
	
	
	// No updating side effects, just calculation:
	double[] newPos = integrator.predictPositions();
	double[] newVels = integrator.predictVelocities();

	double h = integrator.getStepSize();

	//midstep velocity
	for (int i = 0; i < midStepVel.length; i++) {
	    midStepVel[i] = (newPos[i] - X[i]) * (1 / h); //was: Q_dot = (q-X)*(1/h);
	}
	
	HashSet<Collision> cSet = detector.getCollisions();
	
	//iteration counter
	int j = 0;
	if (cSet.size() > 0) {
	    //if count < max iterations or no cap
	    while ( (cSet.size() > 0 && j < iter) || (cSet.size() > 0 && iter == -1) ) {
		j++;
		
		X = scene.getGlobalPositions();
		M = scene.getGlobalMasses();

		//filter velocities
		midStepVel = filter(midStepVel, X, M, cSet);

		//step forward
		integrator.update(midStepPos, midStepVel); // Q = X + h*Q_dot;
		scene.hasStepped(true);

		detector.update();
		cSet = detector.getCollisions();

	    }
	}	
		ArrayList<Particle> parts = scene.getMesh().getParticles();
		newPos = scene.getGlobalPositions();
		newVels = scene.getGlobalVelocities();
		for (int i = 0; i < parts.size(); i++) {
			if(!parts.get(i).isFixed()) {
				parts.get(i).update(new Vector3d(newPos[3*i], newPos[3*i+1], newPos[3*i+2]), 
									new Vector3d(newVels[3*i], newVels[3*i+1], newVels[3*i+2]));
			}
		}
    }

    @SuppressWarnings("unchecked")
    private double[] filter(double[] V, double[] X, double[] M, HashSet<Collision> cSet) {
	for (Collision col : cSet) {
	    //if vertex-face collision
	    if (col.getType() == Collision.VERTEX_FACE) {
		//indicies
		int[] parts = col.getParticles();
		int p = parts[0];
		int a = parts[1];
		int b = parts[2];
		int c = parts[3];
		//barycentric coords
		double[] coords = col.getBaryCoords();
		double u = coords[0];
		double v = coords[1];
		double w = coords[2];

		//collision points
		Vector3d xa = new Vector3d(X[3*p], X[3*p+1], X[3*p+2]);
		Vector3d xb = new Vector3d(u*X[3*a]+v*X[3*b]+w*X[3*c],
					   u*X[3*a+1]+v*X[3*b+1]+w*X[3*c+1],
					   u*X[3*a+2]+v*X[3*b+2]+w*X[3*c+2]);

		//collision velocities
		Vector3d va = new Vector3d(V[3*p], V[3*p+1], V[3*p+2]);
		Vector3d vb = new Vector3d(u*V[3*a]+v*V[3*b]+w*V[3*c],
					   u*V[3*a+1]+v*V[3*b+1]+w*V[3*c+1],
					   u*V[3*a+2]+v*V[3*b+2]+w*V[3*c+2]);
		
		//weighted mass
		double m = 1 / M[3*p] + u*u / M[3*a] + v*v / M[3*b] + w*w / M[3*c];

		//collision normal
		Vector3d norm = xa.minus(xb);
		if(norm.norm() != 0)
		    //following line was: norm = norm / norm.norm();
		    norm = norm.dot(1 / norm.norm());

		//impulse	       
		double I = va.minus(vb).minus(.000001).dot(norm.dot(1 / m));
		
		//Apply impulse
		//apply to vertex
		V[3*p] -= I/M[3*p]*norm.x();
		V[3*p+1] -= I/M[3*p]*norm.y();
		V[3*p+2] -= I/M[3*p]*norm.z();
		//apply to triangle vertices
		V[3*a] += u*I /M[3*a]*norm.x();
		V[3*a+1] += u*I/M[3*a]*norm.y();
		V[3*a+2] += u*I/M[3*a]*norm.z();
		V[3*b] += v*I/M[3*b]*norm.x();
		V[3*b+1] += v*I/M[3*b]*norm.y();
		V[3*b+2] += v*I/M[3*b]*norm.z();
		V[3*c] += w*I/M[3*c]*norm.x();
		V[3*c+1] += w*I/M[3*c]*norm.y();
		V[3*c+2] += w*I/M[3*c]*norm.z();
	    }

	    //edge-edge
	    if (col.getType() == Collision.EDGE_EDGE){
		int[] parts = col.getParticles();
		int p1 = parts[0];
		int q1 = parts[1];
		int p2 = parts[2];
		int q2 = parts[3];
		//barycentric coords
		double[] coords = col.getBaryCoords();
		double s = coords[0];
		double t = coords[1];

		//collision points
		Vector3d xa = new Vector3d(s*X[3*p1]+(1-s)*X[3*q1],
					   s*X[3*p1+1]+(1-s)*X[3*q1+1],
					   s*X[3*p1+2]+(1-s)*X[3*q1+2]);
		Vector3d xb = new Vector3d(t*X[3*p2]+(1-t)*X[3*q2],
					   t*X[3*p2+1]+(1-t)*X[3*q2+1],
					   t*X[3*p2+2]+(1-t)*X[3*q2+2]);

		//collision velocities
		Vector3d va = new Vector3d(s*V[3*p1]+(1-s)*V[3*q1],
					   s*V[3*p1+1]+(1-s)*V[3*q1+1],
					   s*V[3*p1+2]+(1-s)*V[3*q1+2]);
		Vector3d vb = new Vector3d(t*V[3*p2]+(1-t)*V[3*q2],
					   t*V[3*p2+1]+(1-t)*V[3*q2+1],
					   t*V[3*p2+2]+(1-t)*V[3*q2+2]);

		
		//weighted mass
		double m = s*s/M[3*p1]+(1-s)*(1-s)/M[3*q1]+t*t/M[3*p2]+(1-t)*(1-t)/M[3*q2];
		
		//collision norm
		Vector3d norm = xa.minus(xb);
		if(norm.norm() != 0)
		    //following line was: norm = norm / norm.norm();
		    norm = norm.dot(1 / norm.norm());
		
		//impulse
		double I = va.minus(vb).minus(.000001).dot(norm.dot(1/m));
		
		//apply to first edge
		V[3*p1] -= s*I/M[3*p1]*norm.x();
		V[3*p1+1] -= s*I/M[3*p1]*norm.y();
		V[3*p1+2] -= s*I/M[3*p1]*norm.z();
		V[3*q1] -= (1-s)*I/M[3*q1]*norm.x();
		V[3*q1+1] -= (1-s)*I/M[3*q1]*norm.y();
		V[3*q1+2] -= (1-s)*I/M[3*q1]*norm.z();
		//apply to next edge
		V[3*p2] += t*I/M[3*p2]*norm.x();
		V[3*p2+1] += t*I/M[3*p2]*norm.y();
		V[3*p2+2] += t*I/M[3*p2]*norm.z();
		V[3*q2] += (1-t)*I/M[3*q2]*norm.x();
		V[3*q2+1] += (1-t)*I/M[3*q2]*norm.y();
		V[3*q2+2] += (1-t)*I/M[3*q2]*norm.z();
	    }
	}

	return V;
    }



}\end{lstlisting}

\subsection*{feynstein/properties/collision/AxisAlignedBoundingBox.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.geometry.*;

public class AxisAlignedBoundingBox extends BoundingVolume {
    public AxisAlignedBoundingBox() {
	;
    }

    public AxisAlignedBoundingBox(double x_l, double x_u, double y_l, double y_u,
				  double z_l, double z_u) {
	x_lower = x_l;
	x_upper = x_u;
	y_lower = y_l;
	y_upper = y_u;
	z_lower = z_l;
	z_upper = z_u;
    }

    private double getVertex(Triangle t, int vertex, Mesh mesh, int axis) {
	return mesh.getVert(t.getIdx(vertex)).get(axis);
    }

    @Override public void fitTriangle(Triangle t, Mesh mesh) {
	fitTriangle(t, mesh, true);
    }

    public void fitTriangle(Triangle t, Mesh mesh, boolean forceUpdate) {
	if (forceUpdate) {
	    x_lower = x_upper = getVertex(t, 0, mesh, 0);
	    y_lower = y_upper = getVertex(t, 0, mesh, 1);
	    z_lower = z_upper = getVertex(t, 0, mesh, 2);
	}

	for (int vert = forceUpdate ? 1 : 0; vert<3; vert++) {
	    x_lower = Math.min(x_lower, getVertex(t, vert, mesh, 0));
	    y_lower = Math.min(y_lower, getVertex(t, vert, mesh, 1));
	    z_lower = Math.min(z_lower, getVertex(t, vert, mesh, 2));

	    x_upper = Math.max(x_upper, getVertex(t, vert, mesh, 0));
	    y_upper = Math.max(y_upper, getVertex(t, vert, mesh, 1));
	    z_upper = Math.max(z_upper, getVertex(t, vert, mesh, 2));
	}
    }

    @Override public void fitTriangles(Triangle[] ts, Mesh mesh) {
	x_lower = x_upper = getVertex(ts[0], 0, mesh, 0);
	y_lower = y_upper = getVertex(ts[0], 0, mesh, 1);
	z_lower = z_upper = getVertex(ts[0], 0, mesh, 2);

	for (int i=0; i<ts.length; i++) {
	    fitTriangle(ts[i], mesh, false);
	}
    }

    @Override public void addMargin(double margin) {
	x_lower -= margin;
	y_lower -= margin;
	z_lower -= margin;
	x_upper += margin;
	y_upper += margin;
	z_upper += margin;
    }

    @Override @SuppressWarnings("unchecked")
    public void merge(BoundingVolume v1, BoundingVolume v2) {
	if (v1 == null || v2 == null) {
	    AxisAlignedBoundingBox copy = 
		(AxisAlignedBoundingBox) (v1 == null ? v2 : v1);
	    
	    x_lower = copy.x_lower;
	    x_upper = copy.x_upper;
	    y_lower = copy.y_lower;
	    y_upper = copy.y_upper;
	    z_lower = copy.z_lower;
	    z_upper = copy.z_upper;

	    return;
	}

	AxisAlignedBoundingBox aabb1 = (AxisAlignedBoundingBox) v1;
	AxisAlignedBoundingBox aabb2 = (AxisAlignedBoundingBox) v2;

	x_lower = Math.min(aabb1.x_lower, aabb2.x_lower);
	x_upper = Math.max(aabb1.x_upper, aabb2.x_upper);
	y_lower = Math.min(aabb1.y_lower, aabb2.y_lower);
	y_upper = Math.max(aabb1.y_upper, aabb2.y_upper);
	z_lower = Math.min(aabb1.z_lower, aabb2.z_lower);
	z_upper = Math.max(aabb1.z_upper, aabb2.z_upper);
    }

    private boolean spanOverlap(double x1_l, double x1_u, 
				double x2_l, double x2_u) {
	return (x1_l <= x2_u && x2_l <= x1_u) || (x2_l <= x1_u && x1_l <= x2_u);
    }

    @Override @SuppressWarnings("unchecked")	
    public boolean overlaps(BoundingVolume vol) {
	AxisAlignedBoundingBox other = (AxisAlignedBoundingBox) vol;
	return spanOverlap(x_lower, x_upper, other.x_lower, other.x_upper) &&
	    spanOverlap(y_lower, y_upper, other.y_lower, other.y_upper) &&
	    spanOverlap(z_lower, z_upper, other.z_lower, other.z_upper);
    }	    
}\end{lstlisting}

\subsection*{feynstein/properties/collision/TrianglePair.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.geometry.*;
import feynstein.utilities.*;

public class TrianglePair {

    Triangle t1;
    Triangle t2;

    public TrianglePair(Triangle tri1, Triangle tri2) {
	t1 = tri1;
	t2 = tri2;
    }

    public Triangle[] getTriangles() {
	Triangle[] ts = {t1, t2};
	return ts;
    }
}\end{lstlisting}

\subsection*{feynstein/properties/collision/AxisAlignedBoundingBoxTest.java}
\begin{lstlisting}
package feynstein.properties.collision;

public class AxisAlignedBoundingBoxTest {
    public static void main(String args[]) {
	AxisAlignedBoundingBox aabb1 = new AxisAlignedBoundingBox(9, 12, 8, 3, -4, 1);
	AxisAlignedBoundingBox aabb2 = new AxisAlignedBoundingBox(0, 10, 0, 10, 0, 10);
	AxisAlignedBoundingBox aabb3 = new AxisAlignedBoundingBox(15, 20, 5, 15, 8, 18);

	System.out.println(aabb1.overlaps(aabb2));
	System.out.println(aabb2.overlaps(aabb1));
	System.out.println(aabb2.overlaps(aabb3));
	System.out.println(aabb3.overlaps(aabb2));
    }
}\end{lstlisting}

\subsection*{feynstein/properties/collision/ProximityDetector.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;
import feynstein.*;
import feynstein.properties.*;
import java.util.*;

public class ProximityDetector extends NarrowPhaseDetector<ProximityDetector> {

    private double proximity = 0;   

    public ProximityDetector(Scene aScene) {
	super(aScene);
    }

    public ProximityDetector set_proximity(double p) {
	proximity = p;
	return this;
    }
    
    public HashSet<Collision> checkCollision(TrianglePair p, HashSet<Collision> cSet) {
	return checkCollision(p.t1, p.t2, cSet);
    }

    public HashSet<Collision> checkCollision(Triangle t1, Triangle t2, HashSet<Collision> cSet) {
	double[] globalPos = scene.getGlobalPositions();

	// make sure triangles are not connected:
	if (t1.getIdx(0) == t2.getIdx(0) || t1.getIdx(0) == t2.getIdx(1) 
	    || t1.getIdx(0) == t2.getIdx(2) || t1.getIdx(1) == t2.getIdx(0) 
	    || t1.getIdx(1) == t2.getIdx(1) || t1.getIdx(1) == t2.getIdx(2) 
	    || t1.getIdx(2) == t2.getIdx(1) || t1.getIdx(2) == t2.getIdx(1) 
	    || t1.getIdx(2) == t2.getIdx(2)) {
	    return cSet; //can't hit self
	}
	
	double[] a = new double[3];
	double[] b = new double[3];
	double[] c = new double[3];
	double[] p = new double[3];

	// check all 6 vertex-face collisions:
	for (int i = 0; i < 6; i++) {
	    //the triangle with which the vertex is colliding
	    Triangle t;
	    //the colliding vertex
	    int vertex = -1;
	    if (i < 3) {
		t = t2;
		if (i == 0) vertex = t1.getIdx(0);
		if (i == 1) vertex = t1.getIdx(1);
		if (i == 2) vertex = t1.getIdx(2);
	    } else {
		t = t1;
		if(i == 3) vertex = t2.getIdx(0);
		if(i == 4) vertex = t2.getIdx(1);
		if(i == 5) vertex = t2.getIdx(2);
	    }

	    p[0] = globalPos[3*vertex];
	    p[1] = globalPos[3*vertex + 1];
	    p[2] = globalPos[3*vertex + 2];
	    a[0] = globalPos[3*t.getIdx(0)];	
	    a[1] = globalPos[3*t.getIdx(0) + 1];
	    a[2] = globalPos[3*t.getIdx(0) + 2];
	    b[0] = globalPos[3*t.getIdx(1)];
	    b[1] = globalPos[3*t.getIdx(1) + 1];
	    b[2] = globalPos[3*t.getIdx(1) + 2];
	    c[0] = globalPos[3*t.getIdx(2)];
	    c[1] = globalPos[3*t.getIdx(2) + 1];
	    c[2] = globalPos[3*t.getIdx(2) + 2];

	    //barycentric coordinates
	    double u = -1, v = -1, w = -1;

	    //vertex-face distance
	    double[] distAndCoords = DistanceFinder.vertexFaceDistance(p, a, b, c, u, v, w);
	    double distance = Math.sqrt(distAndCoords[0]);
	    u = distAndCoords[1];
	    v = distAndCoords[2];
	    w = distAndCoords[3];

	    //if triangles are within proximity
	    if(distance <= 2 * proximity + .000001) {
		double[] xa = new double[3]; //(was Vector3d xa, xb)
		double[] xb = new double[3];
		xa[0] = p[0];
		xa[1] = p[1];
		xa[2] = p[2];
		xb[0] = u*a[0]+v*b[0]+w*c[0];
		xb[1] = u*a[1]+v*b[1]+w*c[1];
		xb[2] = u*a[2]+v*b[2]+w*c[2];

		cSet.add(new Collision(Collision.VERTEX_FACE, u, v, w, vertex, t.getIdx(0), t.getIdx(1), t.getIdx(2), distance));
	    }
	}
	
	double[] p1 = new double[3];
	double[] q1 = new double[3];
	double[] p2 = new double[3];
	double[] q2 = new double[3];

	//check all 9 edge-edge collisions
	for(int i = 0; i < 9; i++) {
	    //edge indices (so we don't account for the same collision twice)
	    int p_1 = -1, q_1 = -1, p_2 = -1, q_2 = -1;

	    //check all possible edge combinations
	    if (i < 3) {
		p_1 = t1.getIdx(0); 
		q_1 = t1.getIdx(1); 
		if (i == 0) { p_2 = t2.getIdx(0); q_2 = t2.getIdx(1); }
		if (i == 1) { p_2 = t2.getIdx(0); q_2 = t2.getIdx(2); }
		if (i == 2) { p_2 = t2.getIdx(1); q_2 = t2.getIdx(2); }
	    } else if (i < 6) {
		p_1 = t1.getIdx(0); 
		q_1 = t1.getIdx(2);
		if (i == 3) { p_2 = t2.getIdx(0); q_2 = t2.getIdx(1); }
		if (i == 4) { p_2 = t2.getIdx(0); q_2 = t2.getIdx(2); }
		if (i == 5) { p_2 = t2.getIdx(1); q_2 = t2.getIdx(2); }
	    } else if (i < 9) {
		p_1 = t1.getIdx(1);
		q_1 = t1.getIdx(2);
		if (i == 6) { p_2 = t2.getIdx(0); q_2 = t2.getIdx(1); }
		if (i == 7) { p_2 = t2.getIdx(0); q_2 = t2.getIdx(2); }
		if (i == 8) { p_2 = t2.getIdx(1); q_2 = t2.getIdx(2); }
	    }

	    //get edge positions
	    p1[0] = globalPos[3*p_1];
	    p1[1] = globalPos[3*p_1+1];
	    p1[2] = globalPos[3*p_1+2];
	    q1[0] = globalPos[3*q_1];	
	    q1[1] = globalPos[3*q_1+1];
	    q1[2] = globalPos[3*q_1+2];
	    p2[0] = globalPos[3*p_2];
	    p2[1] = globalPos[3*p_2+1];
	    p2[2] = globalPos[3*p_2+2];
	    q2[0] = globalPos[3*q_2];
	    q2[1] = globalPos[3*q_2+1];
	    q2[2] = globalPos[3*q_2+2];

	    //barycentric coordinates
	    double s = -1, t = -1; 

	    //collision
	    double[] distAndCoords = DistanceFinder.edgeEdgeDistance(p1, q1, p2, q2, s, t);
	    double distance = Math.sqrt(distAndCoords[0]);
	    s = distAndCoords[1];
	    t = distAndCoords[2];

	    //edges within proximity
	    if(distance <= 2 * proximity + .000001) {
		cSet.add(new Collision(Collision.EDGE_EDGE, 1.0 - s, 1.0 - t, 0.0, p_1, q_1, p_2, q_2, distance));
	    }
	}
	return cSet;
    }
}\end{lstlisting}

\subsection*{feynstein/properties/collision/Collision.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.geometry.*;

public class Collision {

    int type;
    double[] baryCoords;
    int[] particles;
    double dist;

    /**
       Creates a Collision object with the given data:
       @param typeConstant Collision.VERTEX_FACE or Collision.EDGE_EDGE,
       @param (b1, b2, b3)  barycentric coordinates
       @param (a, b, c, d) four particles defining either 
            [aPoint, faceVertex1, faceVertex2, faceVertex3] or
            [edge1start, edge2start, edge1end, edge2end]
       @param distance between colliding triangles
    */
       
    public Collision(int typeConstant, double bc1, double bc2, double bc3, int a, int b, int c, int d, double distance) {
	type = typeConstant;
	baryCoords = new double[3];
	baryCoords[0] = bc1;
	baryCoords[1] = bc2;
	baryCoords[2] = bc3;

	//store particle indicies
	particles = new int[4];
	particles[0] = a;
	particles[1] = b;
	particles[2] = c;
	particles[3] = d;
	dist = distance;
    }

    public int getType() {
	return type;
    }

    public double[] getBaryCoords() {
	return baryCoords;
    }

    public int[] getParticles() {
	return particles;
    }

    public double getDistance() {
	return dist;
    }

    /**
       Lazy compareTo method implemented so we can make a HashSet of collisions. 
       Returns 0 if the two collisions are equal, -1 otherwise.
    */
    public int compareTo(Collision c)
    {
	if (this.type != c.type) return -1;

	//compare vertex-face
	else if (this.type == VERTEX_FACE) {
	    if (this.particles[0] == c.particles[0] && this.particles[1] == c.particles[1]
		&& this.particles[2] == c.particles[2] && this.particles[3] == c.particles[3]) return 0;
	    return -1;
	}

	//compare edge-edge
	else if (this.type == EDGE_EDGE) {
	    //check all 8 permutations of a combination of 4 edge points
	    //01 23 = 01 23
	    if (this.particles[0]==c.particles[0]&&this.particles[1]==c.particles[1]
		&&this.particles[2]==c.particles[2]&&this.particles[3]==c.particles[3])
		return 0;
	    //01 23 = 23 01
	    if (this.particles[0]==c.particles[2]&&this.particles[1]==c.particles[3]
		&&this.particles[2]==c.particles[0]&&this.particles[3]==c.particles[1])
		return 0;
	    //01 23 = 10 23 
	    if (this.particles[0]==c.particles[1]&&this.particles[1]==c.particles[0]
		&&this.particles[2]==c.particles[2]&&this.particles[3]==c.particles[3])
		return 0;
	    //01 23 = 23 10
	    if (this.particles[0]==c.particles[2]&&this.particles[1]==c.particles[3]
		&&this.particles[2]==c.particles[1]&&this.particles[3]==c.particles[0])
		return 0;
	    //01 23 = 01 32
	    if (this.particles[0]==c.particles[0]&&this.particles[1]==c.particles[1]
		&&this.particles[2]==c.particles[3]&&this.particles[3]==c.particles[2])
		return 0;
	    //01 23 = 32 01
	    if (this.particles[0]==c.particles[3]&&this.particles[1]==c.particles[2]
		&&this.particles[2]==c.particles[0]&&this.particles[3]==c.particles[1])
		return 0;
	    //01 23 = 10 32
	    if (this.particles[0]==c.particles[1]&&this.particles[1]==c.particles[0]
		&&this.particles[2]==c.particles[3]&&this.particles[3]==c.particles[2])
		return 0;
	    //01 23 = 32 10
	    if (this.particles[0]==c.particles[3]&&this.particles[1]==c.particles[2]
		&&this.particles[2]==c.particles[1]&&this.particles[3]==c.particles[0])
		return 0;
	}
	return -1;
    }

    public String toString() {
	String s = "";
	if (type == VERTEX_FACE) {
	    s += "Collision type: vertex-face; ";
	} else if (type == EDGE_EDGE) {
	    s += "Collision type: edge-edge; ";
	}
	s += "between particles " + particles[0] + ", " + particles[1] + ", " + particles[2] + ", and " + particles[3] + "; ";
	s += "at barycentric coords (" + baryCoords[0] + ", " + baryCoords[1] + ", " + baryCoords[2] + "); ";
	s += "with distance = " + dist;
	return s;
    }

    public static final int VERTEX_FACE = 0;
    public static final int EDGE_EDGE = 1;
}\end{lstlisting}

\subsection*{feynstein/properties/collision/CollisionResponder.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.*;
import feynstein.properties.*;

public abstract class CollisionResponder<E extends CollisionResponder> extends Property<E> {
    
    NarrowPhaseDetector detector;
    Scene scene;

    public CollisionResponder(Scene aScene) {
	super(aScene);
	scene = aScene;
    }

    @SuppressWarnings("unchecked")
    public E set_detector(int index) {
	detector = scene.getDetectorByIndex(index);
	return (E) this;
    }

    public abstract void update();

}\end{lstlisting}

\subsection*{feynstein/properties/collision/BoundingVolumeHierarchy.java}
\begin{lstlisting}
package feynstein.properties.collision;

import feynstein.Scene;
import feynstein.geometry.*;
import feynstein.properties.Property;
import feynstein.utilities.Vector3d;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class BoundingVolumeHierarchy extends Property<BoundingVolumeHierarchy> {
    private Node root;
    private VolumeType volumeType = AABB;
    private Mesh mesh;
    private Triangle[] triangles;
    private double margin = 0;
    private LinkedList<TrianglePair> collisions;

    public BoundingVolumeHierarchy(Scene scene) {
	super(scene);

	objectType = "BoundingVolumeHierarchy";
	mesh = scene.getMesh();
	triangles = mesh.getTriangles().toArray(new Triangle[0]);
	collisions = new LinkedList<TrianglePair>();

	System.out.println(triangles.length);
    }

    public BoundingVolumeHierarchy set_margin(double margin) {
	this.margin = margin;
	return this;
    }

    public BoundingVolumeHierarchy set_type(VolumeType type) {
	volumeType = type;
	return this;
    }

    public BoundingVolumeHierarchy compile() {
	if (volumeType == null) {
	    throw new RuntimeException("Bounding volume hierarchies require a volume type.");
	}

	this.root = new Node();
	System.out.println(buildTree(root, triangles, 0));
	return this;
    }

    public Node getRoot() {
	return root;
    }

    public void update() {
	refitBounds(root);
	checkOverlap();
	//System.out.println(root.volume);
    }

    public List<TrianglePair> getCollisions() {
	return collisions;
    }

    private int buildTree(Node root, Triangle[] triangles, int index) {
	root.index = index++;
	
	updateBounds(root, triangles);

	if (triangles.length == 1) {
	    root.triangle = triangles[0];
	    return index;
	} else if (triangles.length == 0) return index;

	int axis = primaryAxis(root);

	int[] indeces = new int[triangles.length];
	for (int i=0; i<triangles.length; i++) {
	    indeces[i] = i;
	}

	sortTriangles(indeces, axis, 0, triangles.length);
	int center = triangles.length / 2;

	root.leftChild = new Node();
	Triangle[] leftHalf = Arrays.copyOfRange(triangles, 0, center);
	index = buildTree(root.leftChild, leftHalf, index);
    
	root.rightChild = new Node();
	Triangle[] rightHalf = Arrays.copyOfRange(triangles, center, triangles.length);
	return buildTree(root.rightChild, rightHalf, index);
    }

    private void updateBounds(Node root, Triangle[] triangles) {
	if (volumeType == VolumeType.AABB) {
	    root.volume = new AxisAlignedBoundingBox();
	    root.volume.fitTriangles(triangles, mesh);
	    root.volume.addMargin(margin);
	} else {
	    throw new RuntimeException("AABB are the only volume types that are supported.");
	}
    }

    private void refitBounds(Node root) {
	if (root.leftChild != null || root.rightChild != null) {
	    refitBounds(root.leftChild);
	    refitBounds(root.rightChild);
	    root.volume.merge(root.leftChild.volume, root.rightChild.volume);
	} else {
	    root.volume.fitTriangle(root.triangle, mesh);
	}
    }

    private int primaryAxis(Node root) {
	double x_span = root.volume.x_upper - root.volume.x_lower;
	double y_span = root.volume.y_upper - root.volume.y_lower;
	double z_span = root.volume.z_upper - root.volume.z_lower;

	if (x_span > y_span)
	    if (x_span > z_span) return 0;
	    else return 2;
	else
	    if (y_span > z_span) return 1;
	    else return 2;
    }

    private double triangleMax(Triangle t, int axis) {
	Vector3d v1 = mesh.getVert(t.getIdx(0)), 
	    v2 = mesh.getVert(t.getIdx(1)), 
	    v3 = mesh.getVert(t.getIdx(2));
	return (v1.get(axis) + v2.get(axis) + v3.get(axis)) / 3.0;
    }

    private void sortTriangles(int[] indeces, int axis, int left, int right) {
	if (left - right < 1) return;

	int i = left, j = right, t;
	int center = indeces[(left + right) / 2];
	double pivot = triangleMax(triangles[center], axis);
	
	while (i <= j) {
	    while (triangleMax(triangles[indeces[i]], axis) < pivot) i++;
	    while (triangleMax(triangles[indeces[j]], axis) > pivot) j--;

	    if (i < j) {
		t = indeces[i];
		indeces[i] = indeces[j];
		indeces[j] = t;
		i++;
		j--;
	    }
	}

	if (left < j)
	    sortTriangles(indeces, axis, left, j);
	if (i < right)
	    sortTriangles(indeces, axis, i, right);
    }

    public void checkOverlap() {
	collisions.clear();
	checkOverlap(root, root, collisions);

	if (collisions.size() > 0) {
	    //System.out.println(collisions.size() + " broad-phase collisions detected");
	}
    }

    private void checkOverlap(Node n1, Node n2, LinkedList<TrianglePair> collisions) {
	/* If the two nodes refer to the same triangle, return. */
	if (n1.isLeaf() && n2.isLeaf() && n1.triangle == n2.triangle) return;
	/* If the nodes do not overlap, return. */
	if (! n1.volume.overlaps(n2.volume)) return;

	/* If we get here, the nodes overlap. If they are both leaf
	 * nodes, then add this pair to the collisions list. */
	if (n1.isLeaf() && n2.isLeaf() && n1.index < n2.index) {
	    if (! n1.triangle.overlaps(n2.triangle)) {
		collisions.offer(new TrianglePair(n1.triangle, n2.triangle));
	    }

	} else if (n1.isLeaf()) {
	    if (n2.leftChild != null)
		checkOverlap(n1, n2.leftChild, collisions);
	    if (n2.rightChild != null)
		checkOverlap(n1, n2.rightChild, collisions);

	} else if (n2.isLeaf()) {
	    if (n1.leftChild != null)
		checkOverlap(n1.leftChild, n2, collisions);
	    if (n1.rightChild != null)
		checkOverlap(n1.rightChild, n2, collisions);

	} else {
	    if (n1.leftChild != null && n2.leftChild != null)
		checkOverlap(n1.leftChild, n2.leftChild, collisions);
	    if (n1.leftChild != null && n2.rightChild != null)
		checkOverlap(n1.leftChild, n2.rightChild, collisions);
	    if (n1.rightChild != null && n2.leftChild != null)
		checkOverlap(n1.rightChild, n2.leftChild, collisions);
	    if (n1.rightChild != null && n2.rightChild != null)
		checkOverlap(n1.rightChild, n2.rightChild, collisions);
	}
    }

    public class Node {
	public Node leftChild, rightChild;
	public BoundingVolume volume;
	int index;
	Triangle triangle;

	public boolean isLeaf() {
	    return leftChild == null && rightChild == null;
	}
    }

    public enum VolumeType { AABB, };
    public static final VolumeType AABB = VolumeType.AABB;
}\end{lstlisting}

\subsection*{feynstein/properties/collision/DistanceFinder.java}
\begin{lstlisting}
package feynstein.properties.collision;

/**
   Utility class for collision detection to compute
   distances between triangles.
*/
public final class DistanceFinder {

    /**
       Finds the distance between two edges of two triangles.
       @param (p1, p2) and (q1, q2): endpoints of edges p and q
       @return An array of [distance, s, t] where s and t are barycentric coords
    */
    public static double[] edgeEdgeDistance(double[] p1, double[] q1, double[] p2, double[] q2, double s, double t) {
	double[] d1 = new double[3];
	double[] d2 = new double[3];
	double[] r = new double[3];
	double a, e, f;
	double[] c1 = new double[3];
	double[] c2 = new double[3];
	
	// d1 == distance between edges' start points:
	d1[0] = q1[0] - p1[0];
	d1[1] = q1[1] - p1[1];
	d1[2] = q1[2] - p1[2];
	
	// d2 == distance between edges' end points
	d2[0] = q2[0] - p2[0];
	d2[1] = q2[1] - p2[1];
	d2[2] = q2[2] - p2[2];

	// r == length of edge p
	r[0] = p1[0] - p2[0];
	r[1] = p1[1] - p2[1];
	r[2] = p1[2] - p2[2];
	
	// ...and this would be where I gave up.
	a = d1[0]*d1[0] + d1[1]*d1[1] + d1[2]*d1[2];
	e = d2[0]*d2[0] + d2[1]*d2[1] + d2[2]*d2[2];
	f = d2[0]*r[0] + d2[1]*r[1] + d2[2]*r[2];
	
	// check if either or both segments degenerate into points
	//
	if ((a <= EPSILON) && (e <= EPSILON)) {
	    s = t = 0.0;
	    c1[0] = p1[0]; c1[1] = p1[1]; c1[2] = p1[2];
	    c2[0] = p2[0]; c2[1] = p2[1]; c2[2] = p2[2];

	    double distance = ((c1[0]-c2[0])*(c1[0]-c2[0]) +
			       (c1[1]-c2[1])*(c1[1]-c2[1]) + (c1[2]-c2[2])*(c1[2]-c2[2]));
	    double[] returnArray = {distance, s, t};
	    return returnArray;
	}

	if (a <= EPSILON) {
	    // first segment degenerates into a point
	    //
	    s = 0.0;
	    t = f / e;
	    if (t < 0.0) t = 0.0;
	    if (t > 1.0) t = 1.0;
	} else {
	    double c = d1[0]*r[0] + d1[1]*r[1] + d1[2]*r[2];
	    
	    if (e <= EPSILON) {
		// second segment degenerates into a point
		//
		t = 0.0;
		s = -c / a;
		if (s < 0.0) s = 0.0;
		if (s > 1.0) s = 1.0;
	    } else {
		// nondegenerate case
		//
		double b = d1[0]*d2[0] + d1[1]*d2[1] + d1[2]*d2[2];
		double denom = a*e - b*b;
	    
		if (denom != 0.0) {
		    s = (b*f - c*e) / denom;
		    if (s < 0.0) s = 0.0;
		    if (s > 1.0) s = 1.0;
		} else {
		    s = 0.0;
		}

		double tnom = b*s + f;
		if (tnom < 0.0) {
		    t = 0.0;
		    s = -c / a;
		    if (s < 0.0) s = 0.0;
		    if (s > 1.0) s = 1.0;
		} else if (tnom > e) {
		    t = 1.0;
		    s = (b - c) / a;
		    if (s < 0.0) s = 0.0;
		    if (s > 1.0) s = 1.0;
		} else {
		    t = tnom / e;
		}
	    }
	}
	
	c1[0] = p1[0] + d1[0] * s;
	c1[1] = p1[1] + d1[1] * s;
	c1[2] = p1[2] + d1[2] * s;

	c2[0] = p2[0] + d2[0] * t;
	c2[1] = p2[1] + d2[1] * t;
	c2[2] = p2[2] + d2[2] * t;

	double distance = ((c1[0]-c2[0])*(c1[0]-c2[0]) +
			   (c1[1]-c2[1])*(c1[1]-c2[1]) + (c1[2]-c2[2])*(c1[2]-c2[2]));
	double[] returnArray = {distance, s, t};
	return returnArray;
    }

    /**
       Finds the distance between a triangle's vertex and another triangle's face.
       @param p A vertex
       @param (a, b, c) Points defining another triangle's face
       @return An array of [distance, t1, t2, t3], where t1-3 are barycentric coords
    */
    public static double[] vertexFaceDistance(double[] p, double[] a, double[] b, double[] c, double t1, double t2, double t3) {
	double[] ab = new double[3];
	double[] ac = new double[3];
	double[] ap = new double[3];
	double[] bp = new double[3];

	ab[0] = b[0] - a[0];
	ab[1] = b[1] - a[1];
	ab[2] = b[2] - a[2];

	ac[0] = c[0] - a[0];
	ac[1] = c[1] - a[1];
	ac[2] = c[2] - a[2];

	ap[0] = p[0] - a[0];
	ap[1] = p[1] - a[1];
	ap[2] = p[2] - a[2];
	
	double d1 = ab[0]*ap[0] + ab[1]*ap[1] + ab[2]*ap[2];
	double d2 = ac[0]*ap[0] + ac[1]*ap[1] + ac[2]*ap[2];

	if ((d1 <= 0.0) && (d2 <= 0.0)) {
	    t1 = 1.0;
	    t2 = 0.0;
	    t3 = 0.0;
	    
	    double distance = ((p[0]-a[0])*(p[0]-a[0]) +
			       (p[1]-a[1])*(p[1]-a[1]) + (p[2]-a[2])*(p[2]-a[2]));
	    double[] returnArray = {distance, t1, t2, t3};
	    return returnArray;
	}
	
	bp[0] = p[0] - b[0];
	bp[1] = p[1] - b[1];
	bp[2] = p[2] - b[2];

	double d3 = ab[0]*bp[0] + ab[1]*bp[1] + ab[2]*bp[2];
	double d4 = ac[0]*bp[0] + ac[1]*bp[1] + ac[2]*bp[2];

	if ((d3 >= 0.0) && (d4 <= d3))	{
	    t1 = 0.0;
	    t2 = 1.0;
	    t3 = 0.0;
	    
	    double distance = ((p[0]-b[0])*(p[0]-b[0]) +
			       (p[1]-b[1])*(p[1]-b[1]) + (p[2]-b[2])*(p[2]-b[2]));
	    double[] returnArray = {distance, t1, t2, t3};
	    return returnArray;
	 }

	 double vc = d1*d4 - d3*d2;

	 if ((vc <= 0.0) && (d1 >= 0.0) && (d3 <= 0.0)) {
	     double v = d1 / (d1 - d3);

	     t1 = 1-v;
	     t2 = v;
	     t3 = 0;

	     double[] vec = new double[3];
	     vec[0] = p[0] - (a[0]+v*ab[0]);
	     vec[1] = p[1] - (a[1]+v*ab[1]);
	     vec[2] = p[2] - (a[2]+v*ab[2]);

	     double distance = (vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
	     double[] returnArray = {distance, t1, t2, t3};
	     return returnArray;
	 }

	 double[] cp = new double[3];
	 cp[0] = p[0] - c[0];
	 cp[1] = p[1] - c[1];
	 cp[2] = p[2] - c[2];

	 double d5 = ab[0]*cp[0] + ab[1]*cp[1] + ab[2]*cp[2];
	 double d6 = ac[0]*cp[0] + ac[1]*cp[1] + ac[2]*cp[2];

	 if ((d6 >= 0.0) && (d5 <= d6))	{
	     t1 = 0.0;
	     t2 = 0.0;
	     t3 = 1.0;

	     double distance = ((p[0]-c[0])*(p[0]-c[0]) +
			       (p[1]-c[1])*(p[1]-c[1]) + (p[2]-c[2])*(p[2]-c[2]));
	    double[] returnArray = {distance, t1, t2, t3};
	    return returnArray;
	}

	double vb = d5*d2 - d1*d6;


	if ((vb <= 0.0) && (d2 >= 0.0) && (d6 <= 0.0)) {
	    double w = d2 / (d2 - d6);
	    
	    t1 = 1 - w;
	    t2 = 0;
	    t3 = w;
	    
	    double[] vec = new double[3];
	    vec[0] = p[0] - (a[0] + w*ac[0]);
	    vec[1] = p[1] - (a[1] + w*ac[1]);
	    vec[2] = p[2] - (a[2] + w*ac[2]);
	    
	    double distance = (vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
	    double[] returnArray = {distance, t1, t2, t3};
	    return returnArray;
	}
	
	double va = d3*d6 - d5*d4;

	if ((va <= 0.0) && ((d4-d3) >= 0.0) && ((d5-d6) >= 0.0)) {
	    double w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
	    
	    t1 = 0;
	    t2 = 1 - w;
	    t3 = w;
	    
	    double[] vec = new double[3];
	    vec[0] = p[0] - (b[0] + w*(c[0]-b[0]));
	    vec[1] = p[1] - (b[1] + w*(c[1]-b[1]));
	    vec[2] = p[2] - (b[2] + w*(c[2]-b[2]));
	    
	    double distance =  (vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
	    double[] returnArray = {distance, t1, t2, t3};
	    return returnArray;
	}
	
	double denom = 1.0 / (va + vb + vc);
	double v = vb * denom;
	double w = vc * denom;
	double u = 1.0 - v - w;

	t1 = u;
	t2 = v;
	t3 = w;

	double[] vec = new double[3];
	vec[0] = p[0] - (u*a[0] + v*b[0] + w*c[0]);
	vec[1] = p[1] - (u*a[1] + v*b[1] + w*c[1]);
	vec[2] = p[2] - (u*a[2] + v*b[2] + w*c[2]);

	double distance = (vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
	double[] returnArray = {distance, t1, t2, t3};
	return returnArray;
    }
    
    public static final double EPSILON = .00000001;

}\end{lstlisting}

\subsection*{feynstein/properties/integrators/SemiImplicitEuler.java}
\begin{lstlisting}
package feynstein.properties.integrators;

import feynstein.*;
import feynstein.geometry.*;
import feynstein.utilities.*;

import java.util.ArrayList;

public class SemiImplicitEuler extends Integrator<SemiImplicitEuler> {

	/**
	 * An Integrator that uses the semi-implicit Euler
	 * method of integration.
	 */
    public SemiImplicitEuler(Scene scene) {
	super(scene);
	objectType = "SemiImplicitEuler";
    }
	
	/*
	 * Semi-implicit integration updates velocities first and then positions.
	 */
	public void update() {
		Scene scene = super.getScene();
		// This is a list of applied force values (in Newtons), in 
		// the x, y, and z directions. The size of this list will
		// be the size of the number of particles in the simulation
		double[] F = scene.globalForceMagnitude();
	
		// grab global list of particles for the scene
		ArrayList<Particle> parts = scene.getMesh().getParticles();
	
		for (int i = 0; i < parts.size(); i++) {
			if(!parts.get(i).isFixed()) {
				Vector3d force = new Vector3d(F[3*i],F[3*i+1],F[3*i+2]);
				// v[1] = v[0] + a*dt = v[0] + dt*f/m
				Vector3d newVel = parts.get(i).getVel().plus(force.dot(h/parts.get(i).getMass()));
				// x[1] = x[0] + v*dt
				Vector3d newPos = parts.get(i).getPos().plus(newVel.dot(h));
				parts.get(i).update(newPos, newVel);
			}
		}
    }

	/*
	 * Semi-implicit integration updates velocities first and then positions.
	 */
    public void update(double[] newPositions, double[] newVelocities) {
		Scene scene = super.getScene();
		ArrayList<Particle> parts = scene.getMesh().getParticles();
		for (int i = 0; i < parts.size(); i++) {
			if(!parts.get(i).isFixed()) {
			// v[1] = v[0] + f/m*dt
			Vector3d newVel = new Vector3d(newVelocities[3*i], newVelocities[3*i+1], newVelocities[3*i+2]);
			// x[1] = x[0] + v*dt
			Vector3d newPos = new Vector3d(newPositions[3*i], newPositions[3*i+1], newPositions[3*i+2]);
			parts.get(i).update(newPos, newVel);
			}
		}
    }

	/*
	 * Predicts the positions on the next update
	 */
    public double[] predictPositions() {
		Scene scene = super.getScene();
		
		double[] F = scene.globalForceMagnitude();
		
		// grab global list of particles for the scene
		ArrayList<Particle> parts = scene.getMesh().getParticles();
		
		double[] newPositions = new double[3 * scene.getMesh().size()];

		for (int i = 0; i < parts.size(); i++) {
			if(!parts.get(i).isFixed()) {
			Vector3d force = new Vector3d(F[3*i],F[3*i+1],F[3*i+2]);
			Vector3d newVel = parts.get(i).getVel().plus(force.dot(h/parts.get(i).getMass()));
			Vector3d newPos = parts.get(i).getPos().plus(newVel.dot(h));
			
			newPositions[3*i] = newPos.x();
			newPositions[3*i+1] = newPos.y();
			newPositions[3*i+2] = newPos.z();
			}
		}
		return newPositions;
    }
	
    /*
	 * Predicts the velocities on the next update
	 */
    public double[] predictVelocities() {
		Scene scene = super.getScene();
		double[] newVelocities = new double[scene.getGlobalVelocities().length];

		double[] F = scene.globalForceMagnitude();
		// grab global list of particles for the scene
		ArrayList<Particle> parts = scene.getMesh().getParticles();
		
		for (int i = 0; i < parts.size(); i++) {
			if(!parts.get(i).isFixed()) {
			Vector3d force = new Vector3d(F[3*i],F[3*i+1],F[3*i+2]);
			Vector3d newVel = parts.get(i).getVel().plus(force.dot(h/parts.get(i).getMass()));
			
			newVelocities[3*i] = newVel.x();
			newVelocities[3*i+1] = newVel.y();
			newVelocities[3*i+2] = newVel.z();
			}
		}
		return newVelocities;
    }
}\end{lstlisting}

\subsection*{feynstein/properties/integrators/Integrator.java}
\begin{lstlisting}
package feynstein.properties.integrators;

import feynstein.*;
import feynstein.properties.*;

public abstract class Integrator<E extends Integrator> extends Property<E> {
    // integration time step
	double h;
	
	/**
	 * A special Property that updates the positions
	 * and velocities of the particles in a Scene
	 * by integrating the active force potentials in
	 * the scene.
	 */
    public Integrator(Scene scene) {
		super(scene);
		objectType = "Integrator";
		h = 0.01;
    }

    public Integrator set_stepSize(double step) {
		h = step;
		return this;
    }
    
    public abstract double[] predictPositions();

    public abstract double[] predictVelocities();

    public abstract void update();

    public abstract void update(double[] newPositions, double[] newVelocities);

    public double getStepSize() {
		return h;
    }
}\end{lstlisting}

\subsection*{feynstein/properties/integrators/VelocityVerlet.java}
\begin{lstlisting}
package feynstein.properties.integrators;

import feynstein.*;
import feynstein.geometry.*;
import feynstein.utilities.*;

import java.util.ArrayList;

public class VelocityVerlet extends Integrator<VelocityVerlet> {
    
	/*
	 * An Integrator that uses the Velocity Verlet
	 * integration method
	 */
	public VelocityVerlet(Scene scene) {
	  super(scene);
	  objectType = "VelocityVerlet";
    }
	
	/*
	 * Verlet integration updates positions, then force potentials, then
	 * velocities
	 */
    public void update() {
	  Scene scene = super.getScene();
	  // This is a list of applied force values (in Newtons), in 
	  // the x, y, and z directions. The size of this list will
	  // be the size of the number of particles in the simulation
	  double[] F = scene.globalForceMagnitude();
	  
	  // grab global list of particles for the scene
	  ArrayList<Particle> parts = scene.getMesh().getParticles();
	
	  double[] newPositions = scene.getGlobalPositions();
	  double[] initialVelocities = scene.getGlobalVelocities();
	  double[] masses = scene.getGlobalMasses();
		
		
	  for (int i = 0; i < parts.size(); i++) {
		if(!parts.get(i).isFixed()) {
		  // a[0] = f(x[0])/m
		  // x[1] = x[0] + v[0]*dt + 0.5*a[0]*dt^2
		  newPositions[3*i] += initialVelocities[3*i]*h+F[3*i]/masses[3*i]*0.5*h*h;
		  newPositions[3*i+1] += initialVelocities[3*i+1]*h+F[3*i+1]/masses[3*i]*0.5*h*h;
		 newPositions[3*i+2] += initialVelocities[3*i+2]*h+F[3*i+2]/masses[3*i]*0.5*h*h;
	    }
	 }
		
	  // get new forces given these positions
	  double[] F_1 = scene.getForcePotential(newPositions, initialVelocities, masses);
	  for (int i = 0; i < parts.size(); i++) {
	    if(!parts.get(i).isFixed()) {
		  Vector3d force = new Vector3d(F[3*i],F[3*i+1],F[3*i+2]);
		  Vector3d newForce = new Vector3d(F_1[3*i],F_1[3*i+1],F_1[3*i+2]);
		  // v[1] = v[0] + 0.5*(a[0]+a[1])*dt
		  Vector3d newVel = parts.get(i).getVel().plus((force.dot(0.5*h/parts.get(i).getMass())
							      .plus(newForce.dot(0.5*h/parts.get(i).getMass()))));
		  // update particle
		  parts.get(i).update(new Vector3d(newPositions[3*i], newPositions[3*i+1], newPositions[3*i+2]), newVel);
	    }
	  }
    }

	/*
	 * Verlet integration updates positions, then force potentials, then
	 * velocities
	 */
    public void update(double[] newPositions, double[] newVelocities) {
	  Scene scene = super.getScene();
	  ArrayList<Particle> parts = scene.getMesh().getParticles();
	  for (int i = 0; i < parts.size(); i++) {
	    if(!parts.get(i).isFixed()) {
	  	  Vector3d newVel = new Vector3d(newVelocities[3*i], newVelocities[3*i+1], newVelocities[3*i+2]);
		  // x[1] = x[0] + v*dt
		  Vector3d newPos = new Vector3d(newPositions[3*i], newPositions[3*i+1], newPositions[3*i+2]);
		  parts.get(i).update(newPos, newVel);
	    }
	  }
    }

    /*
	 * Predicts the positions on the next update
	 */
    public double[] predictPositions() {
	  Scene scene = super.getScene();
	  double[] newPositions = new double[scene.getGlobalPositions().length];
	  double[] F = scene.globalForceMagnitude();
	  ArrayList<Particle> parts = scene.getMesh().getParticles();
	  double[] initialVelocities = scene.getGlobalVelocities();
	  double[] masses = scene.getGlobalMasses();

	  for (int i = 0; i < parts.size(); i++) {
		if(!parts.get(i).isFixed()) {
		  newPositions[3*i] += initialVelocities[3*i]*h+F[3*i]/masses[3*i]*0.5*h*h;
		  newPositions[3*i+1] += initialVelocities[3*i+1]*h+F[3*i+1]/masses[3*i]*0.5*h*h;
		  newPositions[3*i+2] += initialVelocities[3*i+2]*h+F[3*i+2]/masses[3*i]*0.5*h*h;
	    }
	  }
	  return newPositions;
    }

    /*
	 * Predicts the velocites on the next update
	 */
    public double[] predictVelocities() {
	  Scene scene = super.getScene();
	  ArrayList<Particle> parts = scene.getMesh().getParticles();
	  double[] F = scene.globalForceMagnitude();
	  double[] F_1 = scene.getForcePotential(predictPositions(), scene.getGlobalVelocities(), scene.getGlobalMasses());
	  double[] newVelocities = new double[scene.getGlobalVelocities().length];
	  for (int i = 0; i < parts.size(); i++) { 
	    if(!parts.get(i).isFixed()) {
		  Vector3d force = new Vector3d(F[3*i],F[3*i+1],F[3*i+2]);
		  Vector3d newForce = new Vector3d(F_1[3*i],F_1[3*i+1],F_1[3*i+2]);
          Vector3d newVel = parts.get(i).getVel().plus((force.dot(0.5*h/parts.get(i).getMass())
							      .plus(newForce.dot(0.5*h/parts.get(i).getMass()))));
		  newVelocities[3*i] = newVel.x();
		  newVelocities[3*i+1] = newVel.y();
		  newVelocities[3*i+2] = newVel.z();
	    }
	 }
	 return newVelocities;
    }
}\end{lstlisting}

\subsection*{feynstein/renderer/Renderer.java}
\begin{lstlisting}
package feynstein.renderer;

import feynstein.*;
import feynstein.properties.collision.*;
import feynstein.geometry.*;
import feynstein.utilities.*;

import java.awt.Component;
import java.awt.Frame;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
 
import java.io.FileNotFoundException;

import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.GL2ES1;
import javax.media.opengl.GL2GL3;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.awt.GLCanvas;
import javax.media.opengl.fixedfunc.GLLightingFunc;
import javax.media.opengl.fixedfunc.GLMatrixFunc;
import javax.media.opengl.glu.GLU;
import com.jogamp.opengl.util.gl2.GLUT; 
 
import com.jogamp.opengl.util.Animator;


/*
 * The Feynstein Render using Java OpenGL (JOGL)
 */
public class Renderer implements GLEventListener, KeyListener, MouseListener, MouseMotionListener {
    float rotateT = 0.0f;
	
    GLU glu = new GLU();
    GLUT glut = new GLUT();

    static GLCanvas canvas = new GLCanvas();
 
    static Frame frame = new Frame("Feynstein");
 
    static Animator animator = new Animator(canvas);
	
    //camera position on the z axis
    float zpos = 100.0f;
    //camera angle with X axis
    double theta_X = 0.0;
    //camera angle with Y axis
    double theta_Y = 0.0;
    //camera angle with X axis
    double delta_X = 0.0;
    //camera angle with Y axis
    double delta_Y = 0.0;
    //mouse coordinates
    int mouse_X = 0;
    int mouse_Y = 0;
    boolean rotateCamera = false;
    static boolean paused = true;
	
    private final Scene scene;
 
    public Renderer (Scene scene) {
	this.scene = scene;
    }

    public void display(GLAutoDrawable gLDrawable) {
        final GL2 gl = gLDrawable.getGL().getGL2();
        gl.glClear(GL.GL_COLOR_BUFFER_BIT);
        gl.glClear(GL.GL_DEPTH_BUFFER_BIT);
        gl.glLoadIdentity();
		gl.glPushMatrix();
		// moving the camera to zpos is the same as moving all the drawn
	    // primitives to -zpos:
	    gl.glTranslated(0, 0, -zpos);
	    // rotate primitives relative to the camera
	    gl.glRotated(theta_Y, 0.0, 1.0, 0.0);
	    gl.glRotated(theta_X, 1.0, 0.0, 0.0);
      
	    Vector3d pos;
		
	    // render tris
	    gl.glPolygonMode(GL.GL_FRONT_AND_BACK, GL2GL3.GL_FILL);
	    gl.glColor3f(0.4f, 1.0f, 0.0f);
	    gl.glBegin(GL.GL_TRIANGLES);

	    for (Triangle tri: scene.getMesh().getTriangles()) {
	      pos = scene.getMesh().getParticles().get(tri.getIdx(0)).getPos();
	      gl.glVertex3d(pos.x(), pos.y(), pos.z());

	      pos = scene.getMesh().getParticles().get(tri.getIdx(1)).getPos();
	      gl.glVertex3d(pos.x(), pos.y(), pos.z());

	      pos = scene.getMesh().getParticles().get(tri.getIdx(2)).getPos();
	      gl.glVertex3d(pos.x(), pos.y(), pos.z());
	  }

	  gl.glEnd();
		
	  // render edges
	  gl.glColor3f(1.0f, 1.0f, 1.0f);
	  gl.glBegin(GL.GL_LINES);
	  for (Edge e: scene.getMesh().getEdges()) {
	      pos = scene.getMesh().getParticles().get(e.getIdx(0)).getPos();
	      gl.glVertex3d(pos.x(), pos.y(), pos.z());

	      pos = scene.getMesh().getParticles().get(e.getIdx(1)).getPos();
	      gl.glVertex3d(pos.x(), pos.y(), pos.z());
	  }
	  gl.glEnd();
		
	  gl.glPolygonMode(GL.GL_FRONT_AND_BACK, GL2GL3.GL_FILL);
	  // render particles
	  for (Particle p: scene.getMesh().getParticles()) {
	    if (p.getSize() > 0) {
		if (p.isFixed())
		    gl.glColor3f(1.0f, 0.4f, 0.0f);
		else
		    gl.glColor3f(0.0f, 1.0f, 0.4f);
			
		gl.glPushMatrix();
		gl.glTranslated(p.getPos().x(), p.getPos().y(), p.getPos().z());
		glut.glutSolidSphere(p.getSize(), 20, 20);
		gl.glPopMatrix();
	    }
	}

	  gl.glEnd();
	  gl.glPopMatrix();
      
	  if(!paused)
	    scene.update();
    }
 
    public void displayChanged(GLAutoDrawable gLDrawable, boolean modeChanged, boolean deviceChanged) {
    }
 
    public void init(GLAutoDrawable gLDrawable) {
        GL2 gl = gLDrawable.getGL().getGL2();
        gl.glShadeModel(GLLightingFunc.GL_SMOOTH);
        gl.glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
        gl.glClearDepth(1.0f);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glDepthFunc(GL.GL_LEQUAL);
        gl.glHint(GL2ES1.GL_PERSPECTIVE_CORRECTION_HINT, GL.GL_NICEST);

        ((Component) gLDrawable).addKeyListener(this);
		((Component) gLDrawable).addMouseListener(this);
	    ((Component) gLDrawable).addMouseMotionListener(this);
	    // turn on lighting
	    gl.glEnable (gl.GL_LIGHTING);
		
       	// Setup and enable light 0
	    gl.glEnable (gl.GL_LIGHT0);
		
	    // specify the values for the ambient, specular, and diffuse terms:
	    float  ambLight[] = { 0.1f, 0.1f, 0.1f, 1.0f };
	    float  specLight[] = { 1.0f, 1.0f, 1.0f, 1.0f };
	    float  diffLight[] = { 0.25f, 0.25f, 0.25f, 1.0f };
		
	    // set light 0 to use those values:
	    gl.glLightfv (gl.GL_LIGHT0, gl.GL_AMBIENT, ambLight, 0);
		gl.glLightfv (gl.GL_LIGHT0, gl.GL_SPECULAR, specLight, 0);
	    gl.glLightfv (gl.GL_LIGHT0, gl.GL_DIFFUSE, diffLight, 0);
		
	    // set material color
	    gl.glEnable (gl.GL_COLOR_MATERIAL);
		
		// add to materials specular on the front side of geometry
	    gl.glMaterialfv (gl.GL_FRONT, gl.GL_SPECULAR, specLight, 0);
	    gl.glMateriali (gl.GL_FRONT, gl.GL_SHININESS, 100);
		
	    // put the light in a fixed position RELATIVE TO THE CAMERA
	    float lightXYZ[] = { 50.f, 50.0f, 100.0f, 0.0f };
	    gl.glLightfv (gl.GL_LIGHT0, gl.GL_POSITION, lightXYZ, 0);
		
    }
 
	/* Resize open gl window */
    public void reshape(GLAutoDrawable gLDrawable, int x, int y, int width, int height) {
        GL2 gl = gLDrawable.getGL().getGL2();
        if (height <= 0) {
            height = 1;
        }
        float h = (float) width / (float) height;
        gl.glMatrixMode(GLMatrixFunc.GL_PROJECTION);
        gl.glLoadIdentity();
        glu.gluPerspective(50.0f, h, 1.0, 1000.0);
        gl.glMatrixMode(GLMatrixFunc.GL_MODELVIEW);
        gl.glLoadIdentity();
    }
 
	/* Key controls for zoom in/out */
    public void keyPressed(KeyEvent e) {
	  if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
	    exit();
	  }
	  if (e.getKeyCode() == KeyEvent.VK_SPACE) {
	     paused = !paused;
	  }
	  //zoom out
	  if (e.getKeyCode() == 'X') {
	    zpos++;
	  }
	  //zoom in
	  if (e.getKeyCode() == 'Z') {
	    zpos--;
	  }
    }
 
    public void keyReleased(KeyEvent e) {
    }
 
    public void keyTyped(KeyEvent e) {
    }
	
    // mouse event
    public  void mouseClicked(MouseEvent e) {
	
    }
	
    public void	mouseEntered(MouseEvent e) {
	
    }
	
    public void	mouseExited(MouseEvent e) {
	
    }
	
    public void	mousePressed(MouseEvent e) {
	  mouse_X = e.getX();
	  mouse_Y = e.getY();
    }
	
	/*
	 * Sets new camera rotation 
	 */
    public void	mouseReleased(MouseEvent e) {
	  // update the elevation and roll of the camera
	  theta_X += delta_X;
	  theta_Y += delta_Y;
				
	  // reset the change in elevation and roll of the camera
	  delta_X = delta_Y = 0.0;
    }
	
	/*
	 * Rotates the camera on mouse move 
	 */
    public void	mouseDragged(MouseEvent e) {
	  double mouse_dx = e.getX() - mouse_X;
	  double mouse_dy = e.getY() - mouse_Y;
	  delta_X =  mouse_dy/5.0;
	  delta_Y = mouse_dx/5.0;
	  theta_X += delta_X;
	  theta_Y += delta_Y;
	  // reset the change in elevation and roll of the camera
	  delta_X = delta_Y = 0.0;
	  mouse_X = e.getX();
	 mouse_Y = e.getY();
    }
	
    public void	mouseMoved(MouseEvent e) {
		
    }
	 
    public static void exit() {
        animator.stop();
        frame.dispose();
        System.exit(0);
    }
 
    public void dispose(GLAutoDrawable gLDrawable) {
        // do nothing
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/Shape.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.Built;
import feynstein.geometry.Mesh;
import feynstein.geometry.Particle;
import feynstein.geometry.Transform;
import feynstein.utilities.Vector3d;

import java.util.Set;
import java.util.HashSet;

public abstract class Shape<E extends Shape> extends Built<E> {
    protected Mesh localMesh;

    protected Vector3d location = new Vector3d();
    protected Vector3d velocity = new Vector3d();
    protected double mass;
    protected float particleRadius;
    protected String name = null;
    protected boolean fixed = false;
    protected boolean compiled = false;
    protected boolean disableParticleMass = false;
    protected boolean disableParticleVelocity = false;
    protected boolean disableNonzeroParticleVelocity = false;
    protected boolean disableParticleFixed = false;

    protected Set<Particle> particles;

    public Shape() {
	objectType = "Shape";
	mass = 1;
	particleRadius = 0;

	localMesh = new Mesh();
	particles = new HashSet<Particle>();
    }

    public String getName() {
	return name;
    }
	
    public Mesh getLocalMesh() {
	return localMesh;
    }

    @SuppressWarnings("unchecked")
    public E set_name(String name) {
	this.name = name;
	return (E) this;
    }

    @SuppressWarnings("unchecked")
    public E set_location(double x, double y, double z) {
	location = new Vector3d(x, y, z);
	return (E) this;
    }

    @SuppressWarnings("unchecked")
    public E set_velocity(double x, double y, double z) {
	velocity = new Vector3d(x, y, z);
	return (E) this;
    }

    @SuppressWarnings("unchecked")
    public E set_mass(double m) {
	mass = m;
	return (E) this;
    }
	
    @SuppressWarnings("unchecked")
    public E set_particleRadius(float rad) {
	particleRadius = rad;
	return (E) this;
    }

    @SuppressWarnings("unchecked")
    public E set_fixed(boolean fixed) {
	this.fixed = fixed;
	return (E) this;
    }

    public void translate(double dx, double dy, double dz) {
	if (! compiled) {
	    throw new RuntimeException("Shapes must be compiled before transformations can be applied.");
	}

	Vector3d delta = new Vector3d(dx, dy, dz);

	location.add(delta);
	for (Particle p : particles) {
	    p.getPos().add(delta);
	}
    }

    public void scale(double sx, double sy, double sz) {
	if (! compiled) {
	    throw new RuntimeException("Shapes must be compiled before transformations can be applied.");
	}

	Transform scale = Transform.scale(sx, sy, sz);

	scale.apply(location);
	for (Particle p : particles) {
	    scale.apply(p);
	}
    }

    public void rotate(double rx, double ry, double rz) {
	rotate(rx, ry, rz, new int[] {0, 1, 2});
    }

    public void rotate(double rx, double ry, double rz, int[] order) {
	if (! compiled) {
	    throw new RuntimeException("Shapes must be compiled before transformations can be applied.");
	}

	Transform[] transforms = new Transform[3];
	transforms[order[0]] = Transform.rotateX(rx);
	transforms[order[1]] = Transform.rotateY(ry);
	transforms[order[2]] = Transform.rotateZ(rz);
	
	transforms[0].apply(location);
	transforms[1].apply(location);
	transforms[2].apply(location);	

	for (Particle p : particles) {
	    transforms[0].apply(p);
	    transforms[1].apply(p);
	    transforms[2].apply(p);
	}
    }

    @SuppressWarnings("unchecked")
    public final E compile() {
	if (name == null) {
	    throw new RuntimeException("Name missing for " + objectType
				       + "\nYou must specify the name attribute "
				       + "for all shapes.");
	}
		
	compileShape();

	particles.addAll(localMesh.getParticles());
	double particleMass = mass / (double) localMesh.size();
	for (Particle p : particles) {
	    if (! disableParticleMass) p.setMass(particleMass);
	    if (! disableParticleFixed) p.setFixed(fixed);
	    if (! disableParticleVelocity) {
		p.setVel(velocity);
	    } else if (! disableNonzeroParticleVelocity) {
		if (p.getVel().zero()) p.setVel(velocity);
	    }
	}

	compiled = true;
	return (E) this;
    }
	
    @SuppressWarnings("unchecked")
    public E compileShape() {
	/* Can be overridden by shapes if they require it. */
	return (E) this;
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/ClothPiece.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;;

import java.util.ArrayList;
import java.util.HashMap;

public class ClothPiece extends ParticleSet<ClothPiece> {
	
	public ClothPiece() {
		objectType = "ClothPiece";
		particleRadius = 0.2f;
	}
   	
    public ClothPiece compileShape() {
		//super.compileShape();
		for (int i = 0; i < localMesh.size(); i+=4) {
			if(i < localMesh.size() - 2) {
				localMesh.getTriangles().add(new Triangle(i, i+1, i+2));
				localMesh.getTriangles().add(new Triangle(i+2, i+3, i));
			}
		}
		return super.compileShape();
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/Sphere.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public class Sphere extends Shape<Sphere> {
    private double radius;
    private int circle_verts = 50;

    public Sphere() {
	objectType = "Sphere";
    }

    public Sphere set_radius(double r) {
	radius = r;
	return this;
    }

    public Sphere set_accuracy(int verts) {
	circle_verts = verts;
	return this;
    }

    public Sphere compileShape() {
	ArrayList<Particle> particles = new ArrayList<Particle>();
	ArrayList<Edge> edges = new ArrayList<Edge>();
	ArrayList<Triangle> triangles = new ArrayList<Triangle>();

	Vector3d point, center;
	double theta = 2 * Math.PI / (double) circle_verts, 
	    disc_thickness = 2 * radius / (double) circle_verts;
	int index = -1, disc_start = 0, last_disc = -1;

	for (int disc_index=0; disc_index < circle_verts+1; disc_index++) {
	    /* Calculate the radius of this disc. */
	    double disc_r = Math.sqrt(Math.pow(radius, 2) - 
				      Math.pow(2 * radius * disc_index / circle_verts - radius, 2));

	    /* Find the center of this disc. */
	    center = location.plus(new Vector3d(radius, radius, disc_index * disc_thickness));

	    /* If this disc is a cap, then we have to add its
	     * centerpoint to the mesh. If it is not a cap, then
	     * we do not add the center. */
	    disc_start = particles.isEmpty() ? -1 : particles.size() - 1;
		
	    /* Generate this disc by sweeping a circle. */
	    for (int i=1; i<=circle_verts; i++) {
		index = particles.size();
		point = center.plus(new Vector3d(disc_r * Math.cos(theta*i),
						 disc_r * Math.sin(theta*i), 0));
		particles.add(new Particle(point));

		/* Add an edge to the one that came before it in this
		 * disc. */
		if (i > 1) {
		    edges.add(new Edge(index-1, index));
		}

		/* If there was a disc before this one. */
		if (disc_start >= 0) {
		    /* Add an edge to the corresponding point in the
		     * previous disc. */
		    edges.add(new Edge(last_disc+i, index));

		    /* If there is a point before this in the disc */
		    if (i > 1) {
			/* Add an edge along the diagonal of the face
			 * and add the two triangles that make up the
			 * face. */
			edges.add(new Edge(last_disc+i-1, index));
			triangles.add(new Triangle(last_disc+i-1, index-1, index));
			triangles.add(new Triangle(last_disc+i-1, last_disc+i, index));
		    }
		}
	    }

	    /* Create the missing face (the one that links the
	     * starting points and ending points of each face) */
	    if (disc_start >= 0) {
		edges.add(new Edge(disc_start, disc_start+1));
		triangles.add(new Triangle(last_disc+1, disc_start, disc_start+1));
		triangles.add(new Triangle(disc_start, disc_start+1, index));
	    }

	    edges.add(new Edge(disc_start+1, index));
	    if (disc_start > 0) {
		edges.add(new Edge(disc_start, index));
	    }

	    last_disc = disc_start;
	}

	localMesh = new Mesh(particles, edges, triangles);
	return this;
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/Tetrahedron.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.util.Arrays;
import java.util.ArrayList;

public class Tetrahedron extends Shape<Tetrahedron> {
    private Vector3d point1, point2, point3, point4;

    public Tetrahedron() {
	objectType = "Tetrahedron";
    }

    public Tetrahedron set_point1(double x, double y, double z) {
	point1 = new Vector3d(x, y, z);
	return this;
    }

    public Tetrahedron set_point2(double x, double y, double z) {
	point2 = new Vector3d(x, y, z);
	return this;
    }

    public Tetrahedron set_point3(double x, double y, double z) {
	point3 = new Vector3d(x, y, z);
	return this;
    }

    public Tetrahedron set_point4(double x, double y, double z) {
	point4 = new Vector3d(x, y, z);
	return this;
    }

    public Tetrahedron compileShape() {
	/* The particles are just the four points. */
	ArrayList<Particle> particles = new ArrayList<Particle>(
	    Arrays.asList(new Particle[] {
		    new Particle(point1.plus(location)), 
		    new Particle(point2.plus(location)), 
		    new Particle(point3.plus(location)), 
		    new Particle(point4.plus(location))}));

	/* Edges exist between every pair of particles. */
	ArrayList<Edge> edges = new ArrayList<Edge>();
	for (int i=0; i<4; i++) {
	    for (int j=0; j<4; j++) {
		if (i != j) edges.add(new Edge(i,j));
	    }
	}

	/* Four triangles (all possible combinations of four take three) */
	ArrayList<Triangle> triangles = new ArrayList<Triangle>(
	    Arrays.asList(new Triangle[] {
		new Triangle(0,1,2), new Triangle(0,1,3),
		new Triangle(0,2,3), new Triangle(1,2,3)}));

	localMesh = new Mesh(particles, edges, triangles);
	return this;
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/SinglePointMass.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.File;
import java.io.FileReader;
import java.io.FileNotFoundException;

import java.util.ArrayList;
import java.util.StringTokenizer;

public class SinglePointMass extends Shape<SinglePointMass> {
	public SinglePointMass() {
		objectType = "SinglePointMass";
		particleRadius = 1.0f;
	}
    
	public SinglePointMass set_pos(double x, double y, double z) {
		Particle vert = new Particle(new Vector3d(x, y, z));
		localMesh.getParticles().add(vert);
		return this;
	}

    public SinglePointMass compileShape() {
		for (int i = 0; i < localMesh.size(); i++) {
			localMesh.getParticles().get(i).setMass(mass);
			localMesh.getParticles().get(i).setSize(particleRadius);
		}
		return this;
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/Plane.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.utilities.*;

public class Plane extends Shape<Plane> {
    private Vector3d normal;

    public Plane() {
	objectType = "Plane";
    }	

    public Plane set_normal(double x, double y, double z) {
	normal = new Vector3d(x, y, z);
	return this;
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/SpringChain.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.util.ArrayList;

public class SpringChain extends ParticleSet<SpringChain> {
	/* the number of particles to interpolate with spring
	 a value of one indicates to connect springs to the
	 next particle only, a value of n indicates connect n
	 springs between each particle and the next n particles
	 */
	int connectivity;
	
	public SpringChain() {
		objectType = "SpringChain";
		particleRadius = 0.2f;
		connectivity = 1;
	}

	public SpringChain set_connectivity(int connectivity) {
		this.connectivity = connectivity;
		return this;
	}
	
    public SpringChain compileShape() {
		//super.compileShape();
		for (int i = 0; i < localMesh.size(); i++) {
			for(int j = 1; j < connectivity+1; j++) {
				if(i < localMesh.size() - j)
					localMesh.getEdges().add(new Edge(i, i+j));
			}
		}
		return super.compileShape();
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/CustomObject.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.File;
import java.io.FileReader;
import java.io.FileNotFoundException;

import java.util.ArrayList;
import java.util.StringTokenizer;

public class CustomObject extends Shape<CustomObject> {
	private final String VERTEX = "v";
	private final String FACE = "f";
	private final String TEXCOORD = "vt";
	private final String NORMAL = "vn";
	
	private File sourceFile;

	private ArrayList<Particle> verts;
	private ArrayList<Edge> edges;
	private ArrayList<Triangle> tris;
	private ArrayList<Vector3d> normals;

    public CustomObject() {
		objectType = "CustomObject";
		verts = new ArrayList<Particle>();
		edges = new ArrayList<Edge>();
		tris = new ArrayList<Triangle>();
		normals = new ArrayList<Vector3d>();
		
    }
    
    public CustomObject set_file(String filename) {
	sourceFile = new File(filename);
	return this;
    }

    public CustomObject compileShape() {
	if (sourceFile == null) {
	    throw new RuntimeException("You must specify the file " +
				       "attribute of a CustomObject.");
	} else {
		String line;
		try {
			
			BufferedReader buffer = new BufferedReader(new FileReader(sourceFile));
			while ((line = buffer.readLine()) != null) {
				// remove duplicate whitespace
				StringTokenizer parts = new StringTokenizer(line, " ");
				int numTokens = parts.countTokens();
				if (numTokens == 0)
					continue;
				String type = parts.nextToken();
				
				// add vertex to particles list
				if (type.equals(VERTEX)) {
					double x = Float.parseFloat(parts.nextToken());
					double y = Float.parseFloat(parts.nextToken());
					double z = Float.parseFloat(parts.nextToken());
					
					Vector3d vertex = new Vector3d(x,y,z);
					verts.add(new Particle(vertex));
					
				} else if (type.equals(FACE)) {
					
					Triangle newTri = parseTriangleFace(line, numTokens-1);
					tris.add(newTri);
					// add edge for each vertex pair
					for (int i = 0; i < 3; i++) {
						for (int j = i+1; j < 3; j++) {
							edges.add(new Edge(newTri.getIdx(i),newTri.getIdx(j)));
						}
					}
					
				} else if (type.equals(NORMAL)) {
					double x = Float.parseFloat(parts.nextToken());
					double y = Float.parseFloat(parts.nextToken());
					double z = Float.parseFloat(parts.nextToken());
					Vector3d normal = new Vector3d(x,y,z);
					normals.add(normal);
				}  
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		localMesh = new Mesh(verts, edges, tris);
	}
		return this;
    }
	
	private Triangle parseTriangleFace(String line, int faceLength) {
		boolean emptyVt = line.indexOf("//") > -1;
		if(emptyVt) {
			line = line.replace("//", "/");
		}
		StringTokenizer parts = new StringTokenizer(line);
		parts.nextToken();
		StringTokenizer subParts = new StringTokenizer(parts.nextToken(), "/");
		int partLength = subParts.countTokens();
		boolean hasuv = partLength >= 2 && !emptyVt;
		boolean hasn = partLength == 3 || (partLength == 2 && emptyVt);
		
		int [] v = new int[faceLength];
		int [] uv = new int[faceLength];
		int [] n = new int[faceLength];
		
		for (int i = 0; i < faceLength; i++) {
			if (i > 0)
				subParts = new StringTokenizer(parts.nextToken(), "/");
			
			int index = i;
			v[index] = (short) (Short.parseShort(subParts.nextToken()) - 1);
			if (hasuv) {
				uv[index] = (short) (Short.parseShort(subParts.nextToken()) - 1);
			}
			if (hasn) {
				n[index] = (short) (Short.parseShort(subParts.nextToken()) - 1);
			}
		}
		// TODO(sam): this method assumes that face length is 3. If there are more, we 
		// should handle them accordingly
		Triangle t = new Triangle(v);
		if(hasn)
			t.setNormals(normals.get(n[0]), normals.get(n[1]), normals.get(n[2]));
		return t;
	}
}\end{lstlisting}

\subsection*{feynstein/shapes/Cube.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.util.Arrays;
import java.util.ArrayList;

public class Cube extends Shape<Cube> {
    private double side_x, side_y, side_z;

    public Cube() {
	objectType = "Cube";
    }

    public Cube set_sides(double x, double y, double z) {
	side_x = x;
	side_y = y;
	side_z = z;
	return this;
    }

    public Cube set_allSides(double side) {
	side_x = side;
	side_y = side;
	side_z = side;
	return this;
    }

    public Cube compileShape() {
	/*
	 * A cube is defined by 8 points; below, these are referred to
	 * in terms of the "reference corner" (which is the point that the
	 * user specifies as the cube's location). reference_x is
	 * therefore the corner defined by adding the x-length vector to
	 * reference, and reference_yz is the corner defined by adding
	 * the y-length and z-length vectors to reference.
	 */
	Vector3d x_length = new Vector3d(side_x, 0, 0);
	Vector3d y_length = new Vector3d(0, side_y, 0);
	Vector3d z_length = new Vector3d(0, 0, side_z);

	Particle reference = new Particle(location.copy());

	Particle reference_x = new Particle(location.plus(x_length));
	Particle reference_y = new Particle(location.plus(y_length));
	Particle reference_z = new Particle(location.plus(z_length));

	Particle reference_xy = new Particle(location.plus(x_length).plus(y_length));
	Particle reference_xz = new Particle(location.plus(x_length).plus(z_length));
	Particle reference_yz = new Particle(location.plus(y_length).plus(z_length));

	Particle reference_xyz = new Particle(location.plus(x_length)
					      .plus(y_length).plus(z_length));

	/*
	 * Particle IDs are counted as if x, y and z combined to form
	 * a binary number, where x is the MSB and z is the LSB.
	 */
	ArrayList<Particle> particles = new ArrayList<Particle>(
	    Arrays.asList(new Particle[] {
		reference, reference_z, reference_y, reference_yz, 
		reference_x, reference_xz, reference_xy, reference_xyz}));

	/*
	 * Each particle has an edge to any other particle that exists
	 * on the same cube edge that it does (i.e., reference_x and
	 * reference_xz). Also, there are diagonals along each face.
	 */
	ArrayList<Edge> edges = new ArrayList<Edge>(
	    Arrays.asList(new Edge[] {
		new Edge(0,1), new Edge(0,2), new Edge(0,3), new Edge(0,4),
		new Edge(0,5), new Edge(0,6), new Edge(1,3), new Edge(1,5),
		new Edge(1,7), new Edge(2,3), new Edge(2,6), new Edge(2,7), 
		new Edge(3,7), new Edge(4,5), new Edge(4,6), new Edge(4,7), 
		new Edge(5,7), new Edge(6,7)}));

	ArrayList<Triangle> triangles = new ArrayList<Triangle>(
	    Arrays.asList(new Triangle[] {
		new Triangle(0,1,3), new Triangle(0,1,5), new Triangle(0,2,3),
		new Triangle(0,2,6), new Triangle(0,4,5), new Triangle(0,4,6),
		new Triangle(1,3,7), new Triangle(1,5,7), new Triangle(2,3,7),
		new Triangle(2,6,7), new Triangle(4,5,7), new Triangle(4,6,7)}));

	localMesh = new Mesh(particles, edges, triangles);
	return this;
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/FluidPlane.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.util.ArrayList;

public class FluidPlane extends Shape<FluidPlane> {
    private double length_x;
    private double length_y;

    private int subdivisions = 1;

    public FluidPlane() {
	objectType = "FluidPlane";
    }

    public FluidPlane set_lengthX(double x) {
	length_x = x;
	return this;
    }

    public FluidPlane set_lengthY(double y) {
	length_y = y;
	return this;
    }

    public FluidPlane set_length(double l) {
	length_x = l;
	length_y = l;
	return this;
    }

    public FluidPlane set_subdivisions(int s) {
	subdivisions = s;
	return this;
    }

    private int loc(int x, int y) {
	return subdivisions * x + y;
    }

    public FluidPlane compileShape() {
	ArrayList<Particle> particles = new ArrayList<Particle>();
	ArrayList<Edge> edges = new ArrayList<Edge>();
	ArrayList<Triangle> triangles = new ArrayList<Triangle>();

	/* Provides addressing from x-index and y-index (using the
	 * #loc function) to point indeces. */
	int grid[] = new int[subdivisions * subdivisions];

	Vector3d point;

	/* These are the edge lengths of each square that the plane is
	 * composed of. */
	double x_sub_length = length_x / (double) subdivisions;
	double y_sub_length = length_y / (double) subdivisions;

	/* Create the particles. */
	for (int i=0; i<subdivisions; i++) {
	    for (int j=0; j<subdivisions; j++) {
		point = location.plus(new Vector3d(i * x_sub_length, j * y_sub_length, 0));
		grid[loc(i,j)] = particles.size();
		particles.add(new Particle(point));
	    }
	}

	/* Create the edges. */
	for (int i=0; i<subdivisions; i++) {
	    for (int j=0; j<subdivisions; j++) {
		if (i < subdivisions - 1)
		    edges.add(new Edge(grid[loc(i,j)], grid[loc(i+1,j)]));
		if (j < subdivisions - 1)
		    edges.add(new Edge(grid[loc(i,j)], grid[loc(i,j+1)]));
		if (i < subdivisions - 1 && j < subdivisions - 1) {
		    edges.add(new Edge(grid[loc(i,j)], grid[loc(i+1,j+1)]));
		    triangles.add(new Triangle(grid[loc(i,j)], grid[loc(i+1,j)], grid[loc(i+1,j+1)]));
		    triangles.add(new Triangle(grid[loc(i,j)], grid[loc(i,j+1)], grid[loc(i+1,j+1)]));
		}
	    }
	}

	localMesh = new Mesh(particles, edges, triangles);
	return this;
    }		

    private class Loc {
	int x;
	int y;

	public Loc(int x, int y) {
	    this.x = x;
	    this.y = y;
	}
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/Cylinder.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.util.ArrayList;
import java.util.List;

/* TODO haldean: support two-radius cylinders */

public class Cylinder extends Shape<Cylinder> {
    private double radius1, radius2, height;

    /*
     * The circle_verts variable controls how many points are placed
     * along the edge of each cap in the cylinder. The higher the
     * circle_vert value, the more the cylinder will look like a real
     * cylinder and the less it will look like a polygonal prism.
     */
    private int circle_verts = 40;

    public Cylinder() {
	objectType = "Cylinder";
    }
    
    public Cylinder set_radius(double r) {
	radius1 = r;
	radius2 = r;
	return this;
    }

    public Cylinder set_radius1(double r1) {
	radius1 = r1;
	return this;
    }

    public Cylinder set_radius2(double r2) {
	radius2 = r2;
	return this;
    }

    public Cylinder set_height(double h) {
	height = h;
	return this;
    }

    public Cylinder set_accuracy(int verts) {
	circle_verts = verts;
	return this;
    }

    public Cylinder compileShape() {
	ArrayList<Particle> particles = new ArrayList<Particle>();
	ArrayList<Edge> edges = new ArrayList<Edge>();
	ArrayList<Triangle> triangles = new ArrayList<Triangle>();

	List<Vector3d> bottom_ring = new ArrayList<Vector3d>();

	Vector3d point;
	double theta = 2 * Math.PI / (double) circle_verts;
	
	/* Generate the bottom cap. */
	Vector3d bottom_center = location.plus(new Vector3d(radius1, radius1, 0));
	particles.add(new Particle(bottom_center));

	for (int i=0; i<circle_verts; i++) {
	    point = bottom_center.plus(new Vector3d(radius1 * Math.cos(theta * i),
						    radius1 * Math.sin(theta * i), 0));
	    int index = particles.size();
	    particles.add(new Particle(point));
	    bottom_ring.add(point);

	    /* Add an edge to the center point. */
	    edges.add(new Edge(0, index));

	    if (i > 0) {
		/* Add an edge to it's previous neighbor. */
		edges.add(new Edge(index-1, index));
		
		/* Create a triangle between it, its previous neighbor
		 * and the center. */
		triangles.add(new Triangle(0, index-1, index));
	    }
	}

	/* Connect the last point with the first point. */
	edges.add(new Edge(1, circle_verts));
	triangles.add(new Triangle(0, 1, circle_verts));

	/* Generate the top cap. */
	Vector3d height_vector = new Vector3d(0, 0, height),
	    top_center = bottom_center.plus(height_vector);

	/* Generate the center point on the top cap. */
	int top_index = -1, bottom_index, top_center_index = particles.size(),
	    last_bottom_index = particles.size() - 1;
	particles.add(new Particle(top_center));

	/* Add corresponding particles for each particle in the bottom
	 * ring, and create faces out of the rectangles defined by two
	 * corresponding pairs of adjacent points on the caps. */
	for (bottom_index = 1; bottom_index < top_center_index; bottom_index++) {
	    top_index = particles.size();
	    point = top_center.plus(new Vector3d(radius2 * Math.cos(theta * bottom_index),
						 radius2 * Math.sin(theta * bottom_index), 0));

	    /* Add the particle and its edge to the corresponding
	     * particle in the bottom cap. */
	    particles.add(new Particle(point));
	    edges.add(new Edge(bottom_index, top_index));
	    edges.add(new Edge(top_center_index, top_index));

	    /* Create the edge and triangle with its neighbor. */
	    if (top_index-1 > top_center_index) {
		edges.add(new Edge(top_index-1, top_index));
		triangles.add(new Triangle(top_center_index, top_index-1, top_index));
	    }

	    /* Create the face defined by this point, it's
	     * neighbor and the corresponding points in the bottom
	     * cap. */
	    if (bottom_index > 1) {
		edges.add(new Edge(top_index, bottom_index-1));
		triangles.add(new Triangle(bottom_index-1, top_index-1, top_index));
		triangles.add(new Triangle(bottom_index-1, bottom_index, top_index));
	    }
	}

	/* Finish the cap. */
	edges.add(new Edge(top_center_index+1, top_index));
	triangles.add(new Triangle(top_center_index, top_center_index+1, top_index));

	/* Finish the last face with a triangle between the first and
	 * last points in the top and the last point in the bottom. */
	edges.add(new Edge(top_center_index+1, top_index));
	triangles.add(new Triangle(last_bottom_index, top_center_index+1, top_index));
	triangles.add(new Triangle(1, last_bottom_index, top_center_index+1));

	localMesh = new Mesh(particles, edges, triangles);
	return this;
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/ParticleSet.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.util.ArrayList;
import java.util.HashMap;

public class ParticleSet<E extends ParticleSet> extends Shape<E> {
    private ArrayList<Integer> fixedIdx = new ArrayList<Integer>();
    HashMap<Integer, Vector3d> velocityMap = new HashMap<Integer, Vector3d>();
	
    public ParticleSet() {
	objectType = "ParticleSet";
	particleRadius = 0.2f;
	disableParticleMass = true;
	disableParticleFixed = true;
	disableParticleVelocity = true;
    }
    
	 @SuppressWarnings("unchecked")
    public E set_vert(double x, double y, double z) {
	Particle vert = new Particle(new Vector3d(x, y, z));
	localMesh.getParticles().add(vert);
	return (E) this;
    }
	
	@SuppressWarnings("unchecked")
    public E set_fixed(int idx) {
	fixedIdx.add(idx);
	return (E) this;
    }
	
	@SuppressWarnings("unchecked")
    public E set_velocity(int idx, double x, double y, double z) {
	velocityMap.put(idx, new Vector3d(x,y,z));
	return (E) this;
    }

    @SuppressWarnings("unchecked")
    public E compileShape() {
	for(Integer idx : velocityMap.keySet()) {
	    localMesh.getParticles().get(idx).setVel(velocityMap.get(idx));
	    System.out.println("Set vel "+localMesh.getParticles().get(idx).getVel());
	}

	for (Integer idx : fixedIdx) {
	    localMesh.getParticles().get(idx).setFixed(true);
	}

	for (Particle part : localMesh.getParticles()) {
	    part.setMass(mass);
	    part.setSize(particleRadius);
	}

	return (E) this;
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/TriangleShape.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;;

import java.util.ArrayList;

public class TriangleShape extends ParticleSet<TriangleShape> {
	
	public TriangleShape() {
		objectType = "TriangleShape";
		particleRadius = 0.2f;
	}
    
    public TriangleShape compileShape() {
		//this = super.compileShape();
		for(Integer idx : velocityMap.keySet()) {
			localMesh.getParticles().get(idx).setVel(velocityMap.get(idx));
		}		
		for (int i = 0; i < localMesh.size(); i+=3) {
			if(i < localMesh.size() - 2)
				localMesh.getTriangles().add(new Triangle(i, i+1, i+2));
		}
		return super.compileShape();
    }
}\end{lstlisting}

\subsection*{feynstein/shapes/RegularPolygon.java}
\begin{lstlisting}
package feynstein.shapes;

import feynstein.geometry.*;
import feynstein.utilities.Vector3d;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public class RegularPolygon extends Shape<RegularPolygon> {
    private int verteces;
    private double radius;

    public RegularPolygon() {
	objectType = "RegularPolygon";
    }

    public RegularPolygon set_vertices(int verts) {
	verteces = verts;
	return this;
    }

    public RegularPolygon set_radius(double r) {
	radius = r;
	return this;
    }

    public RegularPolygon compileShape() {
	ArrayList<Particle> particles = new ArrayList<Particle>();
	ArrayList<Edge> edges = new ArrayList<Edge>();
	ArrayList<Triangle> triangles = new ArrayList<Triangle>();

	/* The center is the location plus the radius in the X and Y
	 * direction. */
	Vector3d point, center = location.plus(new Vector3d(radius, radius, 0));
	particles.add(new Particle(center));

	double theta = 2 * Math.PI / (double) verteces;
	int index = -1;

	/* Sweep through the polygon and add the verteces. */
	for (int i=0; i<verteces; i++) {
	    index = particles.size();
	    point = center.plus(new Vector3d(radius * Math.cos(theta * i),
					     radius * Math.sin(theta * i), 0));
	    particles.add(new Particle(point));
	    edges.add(new Edge(0, index));

	    if (i > 0) {
		edges.add(new Edge(index-1, index));
		triangles.add(new Triangle(0, index-1, index));
	    }
	}
	
	edges.add(new Edge(1, index));
	triangles.add(new Triangle(0, 1, index));

	localMesh = new Mesh(particles, edges, triangles);
	return this;
    }
}\end{lstlisting}

\subsection*{feynstein/forces/RodBendingForce.java}
\begin{lstlisting}
package feynstein.forces;

import feynstein.geometry.*;
import feynstein.shapes.*;
import feynstein.utilities.*;

public class RodBendingForce extends Force<RodBendingForce> {
    private Shape actsOn;
	private double[] undefLengths;
    private double thetaBar, strength;

	/*
	 * A RodBendingForce is a constraint force acting open three particles
	 * that come to form a single hinge. The energy associated to the
	 * rod-bending force depends upon the current angle, as well as
	 * the undeformed lenghts of the edges, the undeformed-angle, and
	 * the force stiffness.
	 */
    public RodBendingForce() {
		super(3);
		thetaBar = 0.0;
		strength = 1.0;
		objectType = "RodBendingForce";
    }

    public RodBendingForce set_actsOn(Shape s) {
		Edge e1, e2;
		int idx1 = 0;
		int idx2 = 0;
		int idx3 = 0;
		// add a stencil configuration for each pair of connected edges
		for(int i = 0; i < s.getLocalMesh().getEdges().size(); i++) {
			for(int j = i+1; j < s.getLocalMesh().getEdges().size(); j++) {
					e1 = s.getLocalMesh().getEdges().get(i);
					e2 = s.getLocalMesh().getEdges().get(j);
					boolean found = false;
					if (e2.getIdx(0) == e1.getIdx(0)) {
						idx1 = e1.getIdx(1);
						idx2 = e1.getIdx(0);
						idx3 = e2.getIdx(1);
						found = true;
					} else if (e2.getIdx(0) == e1.getIdx(1)) {
						idx1 = e1.getIdx(0);
						idx2 = e1.getIdx(1);
						idx3 = e2.getIdx(1);
						found = true;
					} else if (e2.getIdx(1) == e1.getIdx(0)) {
						idx1 = e1.getIdx(1);
						idx2 = e1.getIdx(0);
						idx3 = e2.getIdx(0);
						found = true;
					} else if (e2.getIdx(1) == e1.getIdx(1)) {
						idx1 = e1.getIdx(0);
						idx2 = e1.getIdx(1);
						idx3 = e2.getIdx(0);
						found = true;
					}
					if(found) {
						stencil.add(idx1);
						stencil.add(idx2);
						stencil.add(idx3);
					}
			}
		}
		actsOn = s;
		return this;
    }

	public RodBendingForce set_angle(double angle) {
		this.thetaBar = angle;
		return this;
	}

    public RodBendingForce set_strength(double strength) {
		this.strength = strength;
		return this;
    }
	
	public double[] getLocalForce(double [] globalPositions,
								  double [] globalVelocities,
								  double [] globalMasses) {
		int n = stencil.size();
		if(localForce == null)
			localForce = new double[3*n];
		if(undefLengths == null) {
			undefLengths = new double[2*stencil.size()/stencilSize];
			int ulIdx = 0;
			for (int i = 0; i < undefLengths.length; i+=2) {
				double [] undefLen = computeUndeformedLengths(globalPositions, stencilSize/2*i);
				undefLengths[ulIdx++] = undefLen[0];
				undefLengths[ulIdx++] = undefLen[1];
			}
		}
		
		double lenij, lenjk;
		
		double xi, xj, xk, yi, yj, yk, zi, zj, zk;
		Vector3d e_ij = new Vector3d(0,0,0);
		Vector3d e_jk = new Vector3d(0,0,0);
		
		int lenIdx = 0;
		for(int i = 0; i < stencil.size(); i += stencilSize) {
			xi = globalPositions[3*stencil.get(i)];
			yi = globalPositions[3*stencil.get(i)+1];
			zi = globalPositions[3*stencil.get(i)+2];
			xj = globalPositions[3*stencil.get(i+1)];
			yj = globalPositions[3*stencil.get(i+1)+1];
			zj = globalPositions[3*stencil.get(i+1)+2];
			xk = globalPositions[3*stencil.get(i+2)];
			yk = globalPositions[3*stencil.get(i+2)+1];
			zk = globalPositions[3*stencil.get(i+2)+2];
			
			lenij = undefLengths[lenIdx];
			lenjk = undefLengths[++lenIdx];
			
			e_ij.set(xi-xj, yi-yj, zi-zj);
			e_jk.set(xj-xk, yj-yk, zj-zk);
			
			Vector3d cross = e_ij.cross(e_jk);
			double theta = Math.atan2(cross.norm(), e_ij.dot(e_jk));
			if(theta == thetaBar) {
				localForce[3*i] = 0;
				localForce[3*i+1] = 0;
				localForce[3*i+2] = 0;
				localForce[3*i+3] = 0;
				localForce[3*i+4] = 0;
				localForce[3*i+5] = 0;
				localForce[3*i+6] = 0;
				localForce[3*i+7] = 0;
				localForce[3*i+8] = 0;
				
			} else if(theta == 0.0){
				localForce[3*i] = 0;
				localForce[3*i+1] = 0;
				localForce[3*i+2] = 0;
				localForce[3*i+3] = 0;
				localForce[3*i+4] = 0;
				localForce[3*i+5] = 0;
				localForce[3*i+6] = 0;
				localForce[3*i+7] = 0;
				localForce[3*i+8] = 0;
			} else {
				localForce[3*i]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(yj - yk)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + 2*(-zj + zk)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((xj - xk)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
				localForce[3*i+1]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(-xj + xk)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + 2*(zj - zk)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((yj - yk)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
				localForce[3*i+2]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(xj - xk)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk) + 2*(-yj + yk)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((zj - zk)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
				localForce[3*i+3]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(-yi + yk)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + 2*(zi - zk)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((xi - 2*xj + xk)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
				localForce[3*i+4]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(xi - xk)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + 2*(-zi + zk)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((yi - 2*yj + yk)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
				localForce[3*i+5]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(-xi + xk)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk) + 2*(yi - yk)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((zi - 2*zj + zk)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
				localForce[3*i+6]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(yi - yj)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + 2*(-zi + zj)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((-xi + xj)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
				localForce[3*i+7]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(-xi + xj)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + 2*(zi - zj)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((-yi + yj)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
				localForce[3*i+8]=(-2*strength*((((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))*(2*(xi - xj)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk) + 2*(-yi + yj)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)))/(2.*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))*(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2))) - ((-zi + zj)*Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))/(Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow ((xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk),2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)))*(-thetaBar + Math.atan2 (Math.sqrt (Math.pow (-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk,2) + Math.pow (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk,2) + Math.pow (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk,2)), (xi - xj)*(xj - xk) + (yi - yj)*(yj - yk) + (zi - zj)*(zj - zk))))/(lenij + lenjk);
			}
		}
		return localForce;
		
		
	}
	
	double[] computeUndeformedLengths(double [] vrt_psns, int i)
	{
		int base0 = 3*stencil.get(i);
		int base1 = 3*stencil.get(i+1);
		int base2 = 3*stencil.get(i+2);
		
		Vector3d pos1, pos2, pos3;
		pos1 = new Vector3d(vrt_psns[base0], vrt_psns[base0+1], vrt_psns[base0+2]);
		pos2 = new Vector3d(vrt_psns[base1], vrt_psns[base1+1], vrt_psns[base1+2]);
		pos3 = new Vector3d(vrt_psns[base2], vrt_psns[base2+1], vrt_psns[base2+2]);
		
		double [] undefLen = new double[2];
		undefLen[0] = (pos1.minus(pos2)).norm();
		undefLen[1] = (pos2.minus(pos3)).norm();
		
		return undefLen;
	}
	
}
\end{lstlisting}

\subsection*{feynstein/forces/TriangleForce.java}
\begin{lstlisting}
package feynstein.forces;

import feynstein.geometry.*;
import feynstein.shapes.*;
import feynstein.utilities.*;

import java.util.ArrayList;

public class TriangleForce extends Force<TriangleForce> {
    private Shape actsOn;
    private double nu, Y;
	private double [] undefVerts;
	
	/*
	 * The TriangleForce is based on a triangle stencil
	 * involving three particles. This force resists both stretching and
	 * compressing the triangular formation and depends upon the undeformed
	 * lengths of the triangle edges, as well as the forces tensile modulus,
	 * a measure of material stiffness, and its Poisson ratio, which relates
	 * material compression to extraction.
	 */
    public TriangleForce() {
		super(3);
		objectType = "TriangleForce";
    }

    public TriangleForce set_actsOn(Shape s) {
		// add a force for each triangle in the mesh
		for(Triangle t : s.getLocalMesh().getTriangles()) {
			for (int i = 0; i < 3; i++) {
				stencil.add(t.getIdx(i));
			}
		}
		actsOn = s;
		
		return this;
    }

    public TriangleForce set_poisson(double poisson) {
		nu = poisson;
		return this;
    }

    public TriangleForce set_youngs(double youngs) {
		Y = youngs;
		return this;
    }
	
	public double[] getLocalForce(double [] globalPositions,
								  double [] globalVelocities,
								  double [] globalMasses) {
		if(undefVerts == null) {
			undefVerts = new double[3*stencil.size()];
			for(int i = 0; i < stencil.size(); i ++) {
				undefVerts[3*i] = globalPositions[3*stencil.get(i)];
				undefVerts[3*i+1] = globalPositions[3*stencil.get(i)+1];
				undefVerts[3*i+2] = globalPositions[3*stencil.get(i)+2];
			}
		}
		
		int n = stencil.size();
		if(localForce == null)
			localForce = new double[3*n];
		
		int base0, base1, base2;
		double x1u, y1u, z1u, x2u, y2u, z2u, x3u, y3u, z3u;
		double x1d, y1d, z1d, x2d, y2d, z2d, x3d, y3d, z3d;
		for(int i = 0; i < stencil.size(); i += stencilSize) {
			// Load undeformed vert positions
			x1u = undefVerts[3*i];
			y1u = undefVerts[3*i+1];
			z1u = undefVerts[3*i+2];
			
			x2u = undefVerts[3*i+3];
			y2u = undefVerts[3*i+4];
			z2u = undefVerts[3*i+5];
			
			x3u = undefVerts[3*i+6];
			y3u = undefVerts[3*i+7];
			z3u = undefVerts[3*i+8];
			
			base0 = 3*stencil.get(i);
			base1 = 3*stencil.get(i+1);
			base2 = 3*stencil.get(i+2);
			// Load deformed vert positions
			x1d = globalPositions[base0];
			y1d = globalPositions[base0+1];
			z1d = globalPositions[base0+2];
			
			x2d = globalPositions[base1];
			y2d = globalPositions[base1+1];
			z2d = globalPositions[base1+2];
			
			x3d = globalPositions[base2];
			y3d = globalPositions[base2+1];
			z3d = globalPositions[base2+2];
			
			// Particle 1, Force x
			//--------------------
			
			double Fx1 = -(Y*((((2*(-1 + nu)*(x1d - x3d)*(square(x1u - x2u) + square(y1u - y2u) + 
														  square(z1u - z2u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								nu*(-(((-2*x1d + x2d + x3d)*
									   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
									(2*(-x1d + x2d)*(square(x1u - x3u) + square(y1u - y3u) + 
													 square(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
								((-1 + nu)*(2*x1d - x2d - x3d)*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (-1 + ((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									  (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + ((-(x3d*((2*(square(x1u - x2u) + square(y1u - y2u) + 
														 square(z1u - z2u)))/
													 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														   (z1u - z2u)*(z1u - z3u)) + 
													  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u))/
													 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														   (z1u - z2u)*(z1u - z3u)) + 
													  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))) + 
											  (2*x1d*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											  (2*x1d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  (x2d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (1 + ((-1 + nu)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											  nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													  (z1d - z2d)*(z1d - z3d))*
													 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
												  ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
														  y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))
											   /(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(x3d*((-2*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										   (z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
									  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))) - 
							   (2*x1d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							   (2*x1d*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
							   (x2d*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  ((nu*((2*(-x1d + x3d)*(square(x1u - x2u) + square(y1u - y2u) + 
													 square(z1u - z2u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
									((-2*x1d + x2d + x3d)*
									 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
								((-1 + nu)*(2*x1d - x2d - x3d)*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								(2*(-1 + nu)*(x1d - x2d)*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
									   (z1d - z2d)*(z1d - z3d))*
									  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + ((-(((2*x1d - x2d - x3d)*
												 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(x1d - x2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													  (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														(z1d - z2d)*(z1d - z3d))*
													   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((2*x1d - x2d - x3d)*
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   (2*(x1d - x2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															   (z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
								  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								   (z1u - z2u)*(z1u - z3u)))/
								 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)) + 
								  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							   ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			
			// Particle 1, Force y
			//--------------------
			
			double Fy1 = -(Y*((((2*(-1 + nu)*(y1d - y3d)*(square(x1u - x2u) + square(y1u - y2u) + 
														  square(z1u - z2u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								nu*(-(((-2*y1d + y2d + y3d)*
									   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
									(2*(-y1d + y2d)*(square(x1u - x3u) + square(y1u - y3u) + 
													 square(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
								((-1 + nu)*(2*y1d - y2d - y3d)*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (-1 + ((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									  (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + ((-(y3d*((2*(square(x1u - x2u) + square(y1u - y2u) + 
														 square(z1u - z2u)))/
													 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														   (z1u - z2u)*(z1u - z3u)) + 
													  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u))/
													 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														   (z1u - z2u)*(z1u - z3u)) + 
													  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))) + 
											  (2*y1d*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											  (2*y1d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  (y2d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (1 + ((-1 + nu)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											  nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													  (z1d - z2d)*(z1d - z3d))*
													 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
												  ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
														  y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))
											   /(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(y3d*((-2*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										   (z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
									  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))) - 
							   (2*y1d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							   (2*y1d*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
							   (y2d*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  ((nu*((2*(-y1d + y3d)*(square(x1u - x2u) + square(y1u - y2u) + 
													 square(z1u - z2u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
									((-2*y1d + y2d + y3d)*
									 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
								((-1 + nu)*(2*y1d - y2d - y3d)*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								(2*(-1 + nu)*(y1d - y2d)*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
									   (z1d - z2d)*(z1d - z3d))*
									  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + ((-(((2*y1d - y2d - y3d)*
												 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(y1d - y2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													  (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														(z1d - z2d)*(z1d - z3d))*
													   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((2*y1d - y2d - y3d)*
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   (2*(y1d - y2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															   (z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
								  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								   (z1u - z2u)*(z1u - z3u)))/
								 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)) + 
								  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							   ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			
			// Particle 1, Force z
			//--------------------
			
			double Fz1 = -(Y*(((-(z3d*((2*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
									   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											 (z1u - z2u)*(z1u - z3u)) + 
										(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
										(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
									   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u))/
									   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											 (z1u - z2u)*(z1u - z3u)) + 
										(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
										(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))) + 
								(2*z1d*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								(2*z1d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								(z2d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (1 + ((-1 + nu)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
										(z1d - z2d)*(z1d - z3d))*
									   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
									((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
								((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
											y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + ((-1 + ((square(x1u - x2u) + square(y1u - y2u) + 
													 square(z1u - z2u))*
													(square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											  ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 ((2*(-1 + nu)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (z1d - z3d))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  nu*(-(((-2*z1d + z2d + z3d)*
													 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
												  (2*(-z1d + z2d)*(square(x1u - x3u) + square(y1u - y3u) + 
																   square(z1u - z3u)))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*(2*z1d - z2d - z3d)*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + ((1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + 
														square(z1u - z2u))*
													   (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													  (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														(z1d - z2d)*(z1d - z3d))*
													   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (-(((2*z1d - z2d - z3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																	  (z1u - z2u)*(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(z1d - z2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + ((-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
													 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
													((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (nu*((2*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (-z1d + z3d))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
												  ((-2*z1d + z2d + z3d)*
												   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*(2*z1d - z2d - z3d)*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  (2*(-1 + nu)*(z1d - z2d)*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))
											   /(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(z3d*((-2*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										   (z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
									  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))) - 
							   (2*z1d*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							   (2*z1d*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
							   (z2d*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  2*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (2*z1d - z2d - z3d))/
								 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)) + 
								  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								 (2*(z1d - z2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)))/
								 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)) + 
								  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
								  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								   (z1u - z2u)*(z1u - z3u)))/
								 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)) + 
								  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							   ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			// Particle 2, Force x
			//--------------------
			
			double Fx2 = -(Y*(((nu*(-(((x1d - x3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
									(2*(x1d - x2d)*(square(x1u - x3u) + square(y1u - y3u) + 
													square(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
								((-1 + nu)*(x1d - x3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (-1 + ((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									  (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) - (((x1d - x3d)*
											  (-(((-1 + nu)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															 (z1u - z2u)*(z1u - z3u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											   (nu*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(-1 + nu)*(x1d - x2d)*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													 (z1d - z2d)*(z1d - z3d))*
													((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) - ((-(((x1d - x3d)*
												 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(x1d - x2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													  (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														(z1d - z2d)*(z1d - z3d))*
													   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((-x1d + x3d)*
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   (2*(-x1d + x2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																(z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
								  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								   (z1u - z2u)*(z1u - z3u)))/
								 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)) + 
								  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							   ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  ((x1d - x3d)*(1 + ((-1 + nu)*
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													(z1d - z2d)*(z1d - z3d))*
												   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
												((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
														y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											  (z1u - z2u)*(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))/
							  ((-1 + 2*nu)*(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)) + 
											(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  (2*(-x1d + x3d)*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)) + 
							   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			// Particle 2, Force y
			//--------------------
			
			double Fy2 = -(Y*(((nu*(-(((y1d - y3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
									(2*(y1d - y2d)*(square(x1u - x3u) + square(y1u - y3u) + 
													square(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
								((-1 + nu)*(y1d - y3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (-1 + ((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									  (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) - (((y1d - y3d)*
											  (-(((-1 + nu)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															 (z1u - z2u)*(z1u - z3u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											   (nu*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(-1 + nu)*(y1d - y2d)*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													 (z1d - z2d)*(z1d - z3d))*
													((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) - ((-(((y1d - y3d)*
												 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(y1d - y2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													  (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														(z1d - z2d)*(z1d - z3d))*
													   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((-y1d + y3d)*
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   (2*(-y1d + y2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																(z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
								  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								   (z1u - z2u)*(z1u - z3u)))/
								 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)) + 
								  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							   ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  ((y1d - y3d)*(1 + ((-1 + nu)*
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													(z1d - z2d)*(z1d - z3d))*
												   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
												((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
														y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											  (z1u - z2u)*(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))/
							  ((-1 + 2*nu)*(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)) + 
											(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  (2*(-y1d + y3d)*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)) + 
							   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			
			// Particle 2, Force z
			//--------------------
			
			double Fz2 = -(Y*(((-1 + ((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									  (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								  (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (nu*(-(((z1d - z3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
									  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											(z1u - z2u)*(z1u - z3u)) + 
									   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
									(2*(z1d - z2d)*(square(x1u - x3u) + square(y1u - y3u) + 
													square(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
								((-1 + nu)*(z1d - z3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) - ((1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + 
														square(z1u - z2u))*
													   (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													  (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														(z1d - z2d)*(z1d - z3d))*
													   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
													  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															(z1u - z2u)*(z1u - z3u)) + 
													   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											  ((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												(z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (-(((z1d - z3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															  (z1u - z2u)*(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(z1d - z2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) - ((-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
													 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
													((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 ((z1d - z3d)*(-(((-1 + nu)*
															  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															   (z1u - z2u)*(z1u - z3u)))/
															 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																   (z1u - z2u)*(z1u - z3u)) + 
															  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
															  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
														   (nu*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																(z1u - z2u)*(z1u - z3u)))/
														   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																 (z1u - z2u)*(z1u - z3u)) + 
															(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
															(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  (2*(-1 + nu)*(z1d - z2d)*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(-z1d + z3d))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   (2*(-z1d + z2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																(z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
								  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
								   (z1u - z2u)*(z1u - z3u)))/
								 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)) + 
								  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							   ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  ((z1d - z3d)*(1 + ((-1 + nu)*
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													(z1d - z2d)*(z1d - z3d))*
												   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
												((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
														y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											  (z1u - z2u)*(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))/
							  ((-1 + 2*nu)*(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)) + 
											(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  (2*(-z1d + z3d)*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)) + 
							   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			
			
			// Particle 3, Force x
			//--------------------
			
			double Fx3 = -(Y*(-((((2*(-1 + nu)*(x1d - x3d)*(square(x1u - x2u) + square(y1u - y2u) + 
															square(z1u - z2u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  ((-1 + nu)*(x1d - x2d)*
								   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  (nu*(-x1d + x2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
								 (-1 + ((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
										(square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
									y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
								(-1 + 2*nu)) - (((2*(x1d - x3d)*
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
												 ((x1d - x2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															   (z1u - z2u)*(z1u - z3u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
												(1 + ((-1 + nu)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
												 nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														 (z1d - z2d)*(z1d - z3d))*
														((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														 (z1u - z2u)*(z1u - z3u)))/
													   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															 (z1u - z2u)*(z1u - z3u)) + 
														(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
														(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
													 ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
													 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														   (z1u - z2u)*(z1u - z3u)) + 
													  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
												 ((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
															 y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
												  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												   (z1u - z2u)*(z1u - z3u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))
											   /(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  ((-2*(-x1d + x3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							   ((-x1d + x2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  ((nu*((2*(x1d - x3d)*(square(x1u - x2u) + square(y1u - y2u) + 
													square(z1u - z2u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
									((x1d - x2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
								((-1 + nu)*(x1d - x2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
									   (z1d - z2d)*(z1d - z3d))*
									  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + (2*(-x1d + x2d)*
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
												 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)) + 
							   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							  ((x1d - x2d)*(1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + 
													  square(z1u - z2u))*
													 (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													(((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													  (z1d - z2d)*(z1d - z3d))*
													 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											  (z1u - z2u)*(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))/
							  ((-1 + 2*nu)*(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)) + 
											(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			
			// Particle 3, Force y
			//--------------------
			
			double Fy3 = -(Y*(-((((2*(-1 + nu)*(y1d - y3d)*(square(x1u - x2u) + square(y1u - y2u) + 
															square(z1u - z2u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  ((-1 + nu)*(y1d - y2d)*
								   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  (nu*(-y1d + y2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
								 (-1 + ((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
										(square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
									y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
								(-1 + 2*nu)) - (((2*(y1d - y3d)*
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
												 ((y1d - y2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															   (z1u - z2u)*(z1u - z3u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
												(1 + ((-1 + nu)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
												 nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														 (z1d - z2d)*(z1d - z3d))*
														((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														 (z1u - z2u)*(z1u - z3u)))/
													   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															 (z1u - z2u)*(z1u - z3u)) + 
														(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
														(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
													 ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
													 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														   (z1u - z2u)*(z1u - z3u)) + 
													  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
												 ((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
															 y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
												  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												   (z1u - z2u)*(z1u - z3u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))
											   /(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  ((-2*(-y1d + y3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							   ((-y1d + y2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  ((nu*((2*(y1d - y3d)*(square(x1u - x2u) + square(y1u - y2u) + 
													square(z1u - z2u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
									((y1d - y2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)))/
									(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										  (z1u - z2u)*(z1u - z3u)) + 
									 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
									 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
								((-1 + nu)*(y1d - y2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   (-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
									   (z1d - z2d)*(z1d - z3d))*
									  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									   (z1u - z2u)*(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
								((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + (2*(-y1d + y2d)*
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
												 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)))/
												(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)) + 
							   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							  ((y1d - y2d)*(1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + 
													  square(z1u - z2u))*
													 (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													(((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													  (z1d - z2d)*(z1d - z3d))*
													 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											  (z1u - z2u)*(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))/
							  ((-1 + 2*nu)*(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)) + 
											(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			
			// Particle 3, Force z
			//--------------------
			
			double Fz3 = -(Y*(-((((2*(-1 + nu)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (z1d - z3d))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  ((-1 + nu)*(z1d - z2d)*
								   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  (nu*(-z1d + z2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
								 (-1 + ((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
										(square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
								  ((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
									y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
								(-1 + 2*nu)) - (((2*(square(x1u - x2u) + square(y1u - y2u) + 
													 square(z1u - z2u))*(z1d - z3d))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
												 ((z1d - z2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															   (z1u - z2u)*(z1u - z3u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
												(1 + ((-1 + nu)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
												 nu*(-((((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
														 (z1d - z2d)*(z1d - z3d))*
														((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														 (z1u - z2u)*(z1u - z3u)))/
													   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
															 (z1u - z2u)*(z1u - z3u)) + 
														(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
														(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
													 ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
													 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														   (z1u - z2u)*(z1u - z3u)) + 
													  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
												 ((-1 + nu)*(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + 
															 y2d*y3d - y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
												  ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												   (z1u - z2u)*(z1u - z3u)))/
												 (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													   (z1u - z2u)*(z1u - z3u)) + 
												  (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												  (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + ((nu*((2*(square(x1u - x2u) + square(y1u - y2u) + 
													  square(z1u - z2u))*(z1d - z3d))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
												  ((z1d - z2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																(z1u - z2u)*(z1u - z3u)))/
												  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														(z1u - z2u)*(z1u - z3u)) + 
												   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
											  ((-1 + nu)*(z1d - z2d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
																	  (z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
											 (-1 - (((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													 (z1d - z2d)*(z1d - z3d))*
													((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											  ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													(z1u - z2u)*(z1u - z3u)) + 
											   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-1 + 2*nu) + 2*(((square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
												 y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d)))/
											   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													 (z1u - z2u)*(z1u - z3u)) + 
												(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
											   ((square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
												((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))
											   /(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)) + 
												 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
												 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							  ((-2*(-z1d + z3d)*((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							   ((-z1d + z2d)*(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
							   (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									 (z1u - z2u)*(z1u - z3u)) + 
								(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
							  (2*(-z1d + z2d)*(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
							   (-(((square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d))*
								   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)))/
								  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
										(z1u - z2u)*(z1u - z3u)) + 
								   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) + 
								((square(x1d) + x2d*x3d - x1d*(x2d + x3d) + square(y1d) + y2d*y3d - 
								  y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
								(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									  (z1u - z2u)*(z1u - z3u)) + 
								 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
								 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))/
							  (-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
									(z1u - z2u)*(z1u - z3u)) + 
							   (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
							   (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
							  ((z1d - z2d)*(1 - nu*(((square(x1u - x2u) + square(y1u - y2u) + 
													  square(z1u - z2u))*
													 (square(x1d - x3d) + square(y1d - y3d) + square(z1d - z3d)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) - 
													(((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - y1d*(y2d + y3d) + 
													  (z1d - z2d)*(z1d - z3d))*
													 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
													  (z1u - z2u)*(z1u - z3u)))/
													(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
														  (z1u - z2u)*(z1u - z3u)) + 
													 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
													 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))) - 
											((-1 + nu)*((x1d - x2d)*(x1d - x3d) + square(y1d) + y2d*y3d - 
														y1d*(y2d + y3d) + (z1d - z2d)*(z1d - z3d))*
											 ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
											  (z1u - z2u)*(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))) + 
											((-1 + nu)*(square(x1d - x2d) + square(y1d - y2d) + square(z1d - z2d))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))/
											(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												  (z1u - z2u)*(z1u - z3u)) + 
											 (square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											 (square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u))))*
							   ((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + (z1u - z2u)*(z1u - z3u)))/
							  ((-1 + 2*nu)*(-square((x1u - x2u)*(x1u - x3u) + (y1u - y2u)*(y1u - y3u) + 
												 (z1u - z2u)*(z1u - z3u)) + 
											(square(x1u - x2u) + square(y1u - y2u) + square(z1u - z2u))*
											(square(x1u - x3u) + square(y1u - y3u) + square(z1u - z3u)))))*
						   Math.sqrt(square(Math.abs(x2u*y1u - x3u*y1u - x1u*y2u + x3u*y2u + x1u*y3u - x2u*y3u)) + 
								square(Math.abs(x2u*z1u - x3u*z1u - x1u*z2u + x3u*z2u + x1u*z3u - x2u*z3u)) + 
								square(Math.abs(y2u*z1u - y3u*z1u - y1u*z2u + y3u*z2u + y1u*z3u - y2u*z3u))))/
			(16.*(1 + nu));
			
			// Sanity check -- sum of internal forces should be zero
			//assert( approxEqual( Fx1+Fx2+Fx3, 0.0 ) );
			//assert( approxEqual( Fy1+Fy2+Fy3, 0.0 ) );
			//assert( approxEqual( Fz1+Fz2+Fz3, 0.0 ) );
			
			localForce[3*i]   = Fx1;
			localForce[3*i+1] = Fy1;
			localForce[3*i+2] = Fz1;
			
			localForce[3*i+3]   = Fx2;
			localForce[3*i+4] = Fy2;
			localForce[3*i+5] = Fz2;
			
			localForce[3*i+6]   = Fx3;
			localForce[3*i+7] = Fy3;
			localForce[3*i+8] = Fz3;
			
		}
		
		return localForce;
	}
	
	private double square(double x) {
		return x*x;
	}
}
\end{lstlisting}

\subsection*{feynstein/forces/SpringForce.java}
\begin{lstlisting}
package feynstein.forces;

import feynstein.geometry.*;
import feynstein.shapes.*;
import feynstein.utilities.*;

import java.util.ArrayList;

public class SpringForce extends Force<SpringForce> {
    private Shape actsOn;
    private double restLength, strength;
	private double undefLengths[];
	
	/*
	 * A SpringForce is a constraint force between two particles. The energy associated to 
	 * the spring force comes from Hooke's law, F=-kx, where k is the spring stiffness, 
	 * and x is the amount of compression (difference between current and rest lengths
	 * for the spring).
	 */
    public SpringForce() {
		super(2);
		restLength = 0.0;
		strength = 10.0;
		objectType = "SpringForce";
    }

    public SpringForce set_actsOn(Shape s) {
		// add spring force for each edge
		for(Edge e : s.getLocalMesh().getEdges()) {
			stencil.add(e.getIdx(0));
			stencil.add(e.getIdx(1));
		}
		actsOn = s;
		return this;
    }

    public SpringForce set_length(double length) {
		this.restLength = length;
		return this;
    }

    public SpringForce set_strength(double strength) {
		this.strength = strength;
		return this;
    }
	
	public double[] getLocalForce(double [] globalPositions,
								  double [] globalVelocities,
								  double [] globalMasses) {
		int n = stencil.size();
		if(localForce == null)
			localForce = new double[3*n];
		
		if(undefLengths == null) {
			undefLengths = new double[stencil.size()/stencilSize];
			int ulIdx = 0;
			for (int i = 0; i < stencil.size(); i+=stencilSize) {
				double undefLen = computeUndeformedLengths(globalPositions, i);
				undefLengths[ulIdx++] = undefLen;
			}
		}
		
		int ulIdx = 0;
		double length, xi, xj, yi, yj, zi, zj;
		for(int i = 0; i < stencil.size(); i += stencilSize) {
			if(restLength > 0)
				length = restLength;
			else 
				length = undefLengths[ulIdx++];
			//edge vectors xi and xj
			xi = globalPositions[3*stencil.get(i)];
			yi = globalPositions[3*stencil.get(i)+1];
			zi = globalPositions[3*stencil.get(i)+2];
			xj = globalPositions[3*stencil.get(i+1)];
			yj = globalPositions[3*stencil.get(i+1)+1];
			zj = globalPositions[3*stencil.get(i+1)+2];
			double normEij = Math.sqrt((xi - xj)*(xi - xj) + (yi - yj)*(yi - yj) + (zi - zj)*(zi - zj));
			localForce[3*i] = -(strength*(xi - xj)*(-length + normEij))/(length*normEij);
			localForce[3*i+1] = -(strength*(yi - yj)*(-length + normEij))/(length*normEij);
			localForce[3*i+2] = -(strength*(zi - zj)*(-length + normEij))/(length*normEij);
			localForce[3*i+3] = -localForce[3*i];
			localForce[3*i+4] = -localForce[3*i+1];
			localForce[3*i+5] = -localForce[3*i+2];
		}
		
		return localForce;
	}
	
	double computeUndeformedLengths(double [] vrt_psns, int i)
	{
		int base0 = 3*stencil.get(i);
		int base1 = 3*stencil.get(i+1);
		
		Vector3d pos1, pos2;
		pos1 = new Vector3d(vrt_psns[base0], vrt_psns[base0+1], vrt_psns[base0+2]);
		pos2 = new Vector3d(vrt_psns[base1], vrt_psns[base1+1], vrt_psns[base1+2]);
		
		return (pos1.minus(pos2)).norm();
		
	}
}
\end{lstlisting}

\subsection*{feynstein/forces/SurfaceBendingForce.java}
\begin{lstlisting}
package feynstein.forces;

import feynstein.geometry.*;
import feynstein.shapes.*;
import feynstein.utilities.*;

import java.util.ArrayList;
import java.util.HashSet;

public class SurfaceBendingForce extends Force<SurfaceBendingForce> {
    private Shape actsOn;
    private double strength;
	private double [] forceScale;
	private double [] undefAngles;
	
	/*
	 * A SurfaceBendingForce is a constraint force that resists the bending
	 * of a four-particle surface along its diagonal. The force energy is
	 * based on the dihedral angle, which is the signed angle between
	 * the normals of the two triangles in the configuration. The
	 * SurfaceBendingForce class is thus parameterized by the undeformed
	 * dihedralangles, the undeformed triangle edge lengths and the force
	 * stiffness constant. 
	 */
    public SurfaceBendingForce() {
		super(4);
		strength = 1.0;
		objectType = "SurfaceBendingForce";
    }

    public SurfaceBendingForce set_actsOn(Shape s) {
		Triangle t1, t2;
		Vector3d pos0, pos1, pos2, pos3;
		int idx1 = 0;
		int idx2 = 0;
		int idx3 = 0;

		/*
		 * For each triangle pair in the mesh, add a stencil configuration
		 */
		for(int i = 0; i < s.getLocalMesh().getTriangles().size(); i++) {
			for(int j = i+1; j < s.getLocalMesh().getTriangles().size(); j++) {
				t1 = s.getLocalMesh().getTriangles().get(i);
				t2 = s.getLocalMesh().getTriangles().get(j);
				// throw the triangle vertices into a set
				// if the set is size 4, we know that they share an edge 
				HashSet<Integer> triIdx = new HashSet<Integer>();
				for(int idx = 0; idx < 3; idx++) {
					triIdx.add(t1.getIdx(idx));
					triIdx.add(t2.getIdx(idx));
				}
				// note : we may need to reorder these to figure out which
				// edge is the common edge and have it in the 
				// middle of the stencil
				// you can do this by seeing which idx do not change the size
				// of the set
				if(triIdx.size()==4) {
					// first add shared verts
					for (Integer idx : triIdx) {
						if(t1.contains(idx) && t2.contains(idx))
							stencil.add(idx);
					}
					for (Integer idx : triIdx) {
						if(!t1.contains(idx) || !t2.contains(idx))
							stencil.add(idx);
					}
				}
			}
		}
		actsOn = s;
		return this;
    }

    public SurfaceBendingForce set_strength(double strength) {
		this.strength = strength;
		return this;
    }
	
	public double[] getLocalForce(double [] globalPositions,
								  double [] globalVelocities,
								  double [] globalMasses) {
		int n = stencil.size();
		
		if(localForce == null)
			localForce = new double[3*n];
		if(forceScale == null) {
			forceScale = new double[stencil.size()/stencilSize];
			int fsIdx = 0;
			for (int i = 0; i < forceScale.length; i++) {
				forceScale[fsIdx++] = precomputeForceScale(globalPositions, stencilSize*i);
			}
		}
		if(undefAngles == null) {
			undefAngles = new double[stencil.size()/stencilSize];
			int uaIdx = 0;
			for (int i = 0; i < undefAngles.length; i++) {
				undefAngles[uaIdx++] = computeUndeformedAngle(globalPositions, stencilSize*i);
			}
		}
		
		double lenij, lenjk;
		
		double xi, xj, xk, xl, yi, yj, yk, yl, zi, zj, zk, zl;
		double thetaBar;
		Vector3d e_ij = new Vector3d(0,0,0);
		Vector3d e_jk = new Vector3d(0,0,0);
		
		int stencilIdx = 0;
		for(int i = 0; i < stencil.size(); i += stencilSize) {
				
			int base0 = 3*stencil.get(i);
			int base1 = 3*stencil.get(i+1);
			int base2 = 3*stencil.get(i+2);
			int base3 = 3*stencil.get(i+3);
		
			xi = globalPositions[base0];
			yi = globalPositions[base0+1];
			zi = globalPositions[base0+2];
			
			xj = globalPositions[base1];
			yj = globalPositions[base1+1];
			zj = globalPositions[base1+2];
			
			xk = globalPositions[base2];
			yk = globalPositions[base2+1];
			zk = globalPositions[base2+2];
			
			xl = globalPositions[base3];
			yl = globalPositions[base3+1];
			zl = globalPositions[base3+2];
			
			thetaBar = undefAngles[stencilIdx];
			double phi = ArcTan((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
								(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
								(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl),
								(-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
								(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
								(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl));

		double Fxi = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(-yj + yl) + (yj - yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(zj - zl) + (-zj + zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(zj - zk) - 
						((-xi + xj)*(-yi + yl)*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) - 
						((-xi + xj)*(-xi + xl)*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) - 
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						((-xi + xj)*(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*(-zi + zl))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(-yj + yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		double Fyi = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((xj - xl)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + (-xj + xk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(-zj + zl) + (zj - zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zj + zk) - 
						((-yi + yj)*(-yi + yl)*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) - 
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) - 
						((-xi + xl)*(-yi + yj)*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) - 
						((-yi + yj)*(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*(-zi + zl))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(xj - xk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		double Fzi = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-xj + xl)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk) + (yj - yl)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk) + 
						(xj - xk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + (-yj + yk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-xi + xl)*(yj - yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(-xj + xk)*(-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) - 
						((-yi + yl)*(-zi + zj)*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) - 
						((-xi + xl)*(-zi + zj)*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) - 
						((xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*(-zi + zj)*(-zi + zl))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		
		double Fxj = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(yi - yl) + (-yi + yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-zi + zl) + (zi - zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zk) + 
						((-xi + xj)*(-yi + yl)*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						((-xi + xj)*(-xi + xl)*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						((-xi + xj)*(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*(-zi + zl))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(yi - yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		double Fyj = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-xi + xl)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + (xi - xk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(zi - zl) + (-zi + zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(zi - zk) + 
						((-yi + yj)*(-yi + yl)*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						((-xi + xl)*(-yi + yj)*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						((-yi + yj)*(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*(-zi + zl))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(-xi + xk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		double Fzj = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((xi - xl)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk) + (-yi + yl)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk) + 
						(-xi + xk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + (yi - yk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-xi + xl)*(-yi + yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(xi - xk)*(-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						((-yi + yl)*(-zi + zj)*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						((-xi + xl)*(-zi + zj)*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						((xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*(-zi + zj)*(-zi + zl))/
						Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		
		double Fxk = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((yi - yj)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + (-zi + zj)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-yi + yl)*(zi - zj)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(-yi + yj)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		double Fyk = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-xi + xj)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + (zi - zj)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-xi + xl)*(-zi + zj)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(xi - xj)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		double Fzk = (((-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))*
					   ((xi - xj)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + (-yi + yj)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (((-xi + xl)*(yi - yj)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)) + 
						(-xi + xj)*(-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj)))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		
		double Fxl = ((((-yi + yj)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + (zi - zj)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk))*
					   (-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						  (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk)*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		double Fyl = ((((xi - xj)*(-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk) + (-zi + zj)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk))*
					   (-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						  (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  (Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		double Fzl = ((((-xi + xj)*(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk) + (yi - yj)*(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk))*
					   (-((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						  (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk)) - 
						(-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) - 
						(xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))) + 
					  ((xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
					   ((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
						(xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
						(-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl)))/
					  (square((-yi + yl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*
						   (-(xj*zi) + xk*zi + xi*zj - xk*zj - xi*zk + xj*zk) + 
						   (-xi + xl)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(yj*zi - yk*zi - yi*zj + yk*zj + yi*zk - yj*zk) + 
						   (xj*yi - xk*yi - xi*yj + xk*yj + xi*yk - xj*yk)*Math.sqrt(square(-xi + xj) + square(-yi + yj) + square(-zi + zj))*(-zi + zl))
					   + square((-(xj*yi) + xk*yi + xi*yj - xk*yj - xi*yk + xj*yk)*(xj*yi - xl*yi - xi*yj + xl*yj + xi*yl - xj*yl) + 
							 (xj*zi - xk*zi - xi*zj + xk*zj + xi*zk - xj*zk)*(-(xj*zi) + xl*zi + xi*zj - xl*zj - xi*zl + xj*zl) + 
							 (-(yj*zi) + yk*zi + yi*zj - yk*zj - yi*zk + yj*zk)*(yj*zi - yl*zi - yi*zj + yl*zj + yi*zl - yj*zl))))*
		(-thetaBar + phi);
		
				
		Fxi *= -forceScale[stencilIdx];
		Fyi *= -forceScale[stencilIdx];
		Fzi *= -forceScale[stencilIdx];
		Fxj *= -forceScale[stencilIdx];
		Fyj *= -forceScale[stencilIdx];
		Fzj *= -forceScale[stencilIdx];
		Fxk *= -forceScale[stencilIdx];
		Fyk *= -forceScale[stencilIdx];
		Fzk *= -forceScale[stencilIdx];
		Fxl *= -forceScale[stencilIdx];
		Fyl *= -forceScale[stencilIdx];
		Fzl *= -forceScale[stencilIdx];
		stencilIdx++;
		
		localForce[3*i]   = Fxi;
		localForce[3*i+1] = Fyi;
		localForce[3*i+2] = Fzi;
		
		localForce[3*i+3]   = Fxj;
		localForce[3*i+4] = Fyj;
		localForce[3*i+5] = Fzj;
		
		localForce[3*i+6]   = Fxk;
		localForce[3*i+7] = Fyk;
		localForce[3*i+8] = Fzk;
		
		localForce[3*i+9]   = Fxl;
		localForce[3*i+10] = Fyl;
		localForce[3*i+11] = Fzl;
			
		}
		return localForce;
	
	}
	
	double ArcTan(double a, double b)
	{
		return Math.atan2( b, a );
	}
	
	double computeNormEij(double [] vrt_psns, int i) {
		int base0 = 3*stencil.get(i);
		int base1 = 3*stencil.get(i+1);
		
		Vector3d verti = new Vector3d( vrt_psns[base0], vrt_psns[base0+1], vrt_psns[base0+2] );
		Vector3d vertj = new Vector3d( vrt_psns[base1], vrt_psns[base1+1], vrt_psns[base1+2] );
		
		return (vertj.minus(verti)).norm();
	}
	
	double computehij(double [] vrt_psns, int i) {
		int base0 = 3*stencil.get(i);
		int base1 = 3*stencil.get(i+1);
		int base2 = 3*stencil.get(i+2);
		int base3 = 3*stencil.get(i+3);
		
		Vector3d verti = new Vector3d( vrt_psns[base0], vrt_psns[base0+1], vrt_psns[base0+2] );
		Vector3d vertj = new Vector3d( vrt_psns[base1], vrt_psns[base1+1], vrt_psns[base1+2] );
		Vector3d vertk = new Vector3d( vrt_psns[base2], vrt_psns[base2+1], vrt_psns[base2+2] );
		Vector3d vertl = new Vector3d( vrt_psns[base3], vrt_psns[base3+1], vrt_psns[base3+2] );
		
		Vector3d eij = verti.minus(vertj);
		Vector3d ekj = vertk.minus(vertj);
		Vector3d elj = vertl.minus(vertj);
		
		double A0 = 0.5*(eij.cross(ekj)).norm();
		double A1 = 0.5*(eij.cross(elj)).norm();
		
		return (2.0/3.0)*(A0+A1)*(1.0/computeNormEij(vrt_psns, i));
	}
	
	double precomputeForceScale(double [] vrt_psns, int i) {
		
		return 2.0*strength*computeNormEij(vrt_psns, i)*(1.0/computehij(vrt_psns, i));
	}
	
	double computeUndeformedAngle(double [] vrt_psns, int i)
	{
		int base0 = 3*stencil.get(i);
		int base1 = 3*stencil.get(i+1);
		int base2 = 3*stencil.get(i+2);
		int base3 = 3*stencil.get(i+3);
		
		Vector3d ev =  (new Vector3d( vrt_psns[base1], vrt_psns[base1+1], vrt_psns[base1+2])).minus(
					   new Vector3d( vrt_psns[base0], vrt_psns[base0+1], vrt_psns[base0+2]));
		
		// compute normals of the two deformed triangles and the angle between them
		//
		Vector3d n1 = ev.cross((new Vector3d( vrt_psns[base2], vrt_psns[base2+1], vrt_psns[base2+2])).minus(
							   new Vector3d( vrt_psns[base0], vrt_psns[base0+1], vrt_psns[base0+2])));
		Vector3d n2 = ((new Vector3d( vrt_psns[base3], vrt_psns[base3+1], vrt_psns[base3+2])).minus(
					   new Vector3d( vrt_psns[base0], vrt_psns[base0+1], vrt_psns[base0+2]))).cross(ev);
		
		ev.normalize();
		return Math.atan2(n1.cross(n2).dot(ev), n1.dot(n2));
	}
	
	private double square(double x) {
		return x*x;
	}
	
}
\end{lstlisting}

\subsection*{feynstein/forces/Force.java}
\begin{lstlisting}
package feynstein.forces;

import feynstein.Built;

import java.util.ArrayList;

public abstract class Force<E extends Force> extends Built<E> {
	protected int stencilSize;
	protected int meshSize;
	protected ArrayList<Integer> stencil;
	protected double[] localForce;
	
    public Force(int stencilSize) {
		objectType = "Force";
		this.stencilSize = stencilSize;
		stencil = new ArrayList<Integer>();
	}
	
	public boolean isGlobal() {
		return !(stencilSize > 0); 
	}
	
	public int getStencilIdx(int idx) {
		return stencil.get(idx);
	}
	
	public abstract double[] getLocalForce(double [] globalPositions,
										   double [] globalVelocities,
										   double [] globalMasses);
}\end{lstlisting}

\subsection*{feynstein/forces/DampingForce.java}
\begin{lstlisting}
package feynstein.forces;

import feynstein.geometry.*;
import feynstein.shapes.*;

import java.util.ArrayList;

/*
 * A global DampingForce that acts opposite the velocities of
 * All particles in the scene. Configured by a single damping
 * coefficient.
 */
public class DampingForce extends Force<DampingForce> {
	private double coefficient;

    public DampingForce() {
		super(0);
		objectType = "Damping";
		coefficient = 0.1;
    }
 
    public DampingForce set_coefficient(double coefficient) {
		this.coefficient = coefficient;
		return this;
    }

	public double[] getLocalForce(double [] globalPositions,
										   double [] globalVelocities,
										   double [] globalMasses) {
		int n = globalPositions.length;
		if(localForce == null)
			localForce = new double[n];
		
		//F = -ymv
		for(int i = 0; i < n/3; i++){
			localForce[3*i] = -coefficient*globalMasses[3*i]*globalVelocities[3*i];
			localForce[3*i+1] = -coefficient*globalMasses[3*i]*globalVelocities[3*i+1];
			localForce[3*i+2] = -coefficient*globalMasses[3*i]*globalVelocities[3*i+2];
		}
		
		return localForce;
	}
}
\end{lstlisting}

\subsection*{feynstein/forces/GravityForce.java}
\begin{lstlisting}
package feynstein.forces;

import feynstein.geometry.*;
import feynstein.shapes.*;

import java.util.ArrayList;

/*
 * A global GravityForce that applies a constant acceleration in
 * one of more of three direction to all particles in the Scene.
 */
public class GravityForce extends Force<GravityForce> {
	private double gx;
	private double gy;
	private double gz;

    public GravityForce() {
		super(0);
		objectType = "Gravity";
		gx = 0;
		gy = 0;
		gz = 0;
    }
 
    public GravityForce set_gx(double gx) {
		this.gx = gx;
		return this;
    }
	
	public GravityForce set_gy(double gy) {
		this.gy = gy;
		return this;
    }
	
	public GravityForce set_gz(double gz) {
		this.gz = gz;
		return this;
    }

	public double[] getLocalForce(double [] globalPositions,
										   double [] globalVelocities,
										   double [] globalMasses) {
		int n = globalPositions.length;
		if(localForce == null)
			localForce = new double[n];
		
		for(int i = 0; i < n/3; i++){
			localForce[3*i] = globalMasses[3*i]*gx;
			localForce[3*i+1] = globalMasses[3*i]*gy;
			localForce[3*i+2] = globalMasses[3*i]*gz;
		}
		
		return localForce;
	}
}
\end{lstlisting}

